LIB "mcgb.lib";

proc show_list_to_file(list l, link out) {
  int i;
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    for (i = 1; i <= size(l); i++) {
      fprintf(out, "        %s,", string(l[i]));
    }
  }
}

proc gen_largest_proper_sublists(list l)
"USAGE:    Generate all sublists of with size of size(l)-1
RETURN:    A list of such sublists."
{
  if (size(l) <= 1) {
    return (list());
  }

  list sub_lists;
  int i;
  for (i = 1; i <= size(l); i++) {
    list l_sub = delete(l, i);
    sub_lists = insert(sub_lists, l_sub, size(sub_lists));
  }

  return (sub_lists);
}

proc list_diff(list L1, list L2) {
  if (size(L1) == 0) {
    return (list());
  }

  if (size(L2) == 0) {
    return (L1);
  }

  int i;
  list res;
  for (i = 1; i <= size(L1); i++) {
    if (!listContains(L2, L1[i])) {
      res = insert(res, L1[i], size(res));
    }
  }

  return (res);
}

proc check_comprehensive(list M, list CGS) {
  // Basering is @R.
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "M is empty.");
    }
    return (0);
  }

  // Switch to @RP.
  setring @RP;
  def M = imap(@R, M);
  def CGS = imap(@R, CGS);

  int i, j;
  for (i = 1; i <= size(CGS); i++) {
    if (size(CGS[i][3]) > 0) {
      for (j = 1; j <= size(CGS[i][3]); j++) {
	poly f = monic(CGS[i][3][j][1] + CGS[i][3][j][2]);

	if (!listContains(M, f)) {
	  poly pp_f = lppX(CGS[i][3][j][1]);
	  ideal E_cur = CGS[i][1];
	  list N_cur = CGS[i][2];
	  if (size(N_cur) == 0) {
	    N_cur = list(1);
	  }

	  list G_branch = CGS[i][3];
	  int is_essential;
	  list DontCare;
	  (is_essential, DontCare) = checkEssentialInBranch(f, pp_f, M, E_cur, N_cur, G_branch, DontCare);
	  if (is_essential) {
	    return (0);
	  }
	}
      } // End for.
    }
  } // End for.

  return (1);
}

proc check_minimal(list M, list CGS) {
  if (size(CGS) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "CGS is empty.");
    }
    return (1);
  }

  if (size(M) == 0) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "G is empty.");
    }
    return (0);
  }

  list M_subs = gen_largest_proper_sublists(M);

  int i, j;
  for (i = 1; i <= size(M_subs); i++) {
    // For each maximal proper subset of M.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$");
      fprintf(out, "%s. Now check M_sub[%s] = [", string(i), string(i));
      show_list_to_file(M_subs[i], out);
      fprintf(out, "    ]:");
    }

    if (check_comprehensive(M_subs[i], CGS)) {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is also a CGS of <F>.", string(i));
      }
      return (0);
    } else {
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "The subset M_sub[%s] is not comprehensive.", string(i));
      }
    }
  } // End for.
  return (1);
}

proc check_validity(list M, list CGS) {
  // Basering is @R.
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "============================");
    fprintf(out, "Now check whether M is comprehensive and minimal:");
    fprintf(out, "------------------");

    fprintf(out, "First, check the comprehensiveness of M:" + newline);
  }

  if (check_comprehensive(M, CGS)) {
    // M is comprehensive, then check the minimality.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is comprehensive.");
      fprintf(out, newline + newline + "================================");
      fprintf(out, "Second, check the minimality of M:");
    }
    if (check_minimal(M, CGS)) {
      // M is also minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is minimal.");
      }
      fprintf(out, "It is comprehensive and minimal.");
      return (1);
    } else {
      // M is not minimal.
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, newline + "M is not minimal.");
      }
      fprintf(out, "It is comprehensive, but not minimal.");
      return (-1);
    }
  } else {
    // M is not comprehensive.
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, newline + "M is not comprehensive.");
    }
    fprintf(out, "It is not comprehensive.");
    return (0);
  }
}

