LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.lib";

proc set_global_rings() {
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);

  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;

  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);
  setring(BR);
	
}
	
proc listToVec(list l) {
    vector v;
    int i;

    for (i = 1; i <= size(l); i++) {
	v = v + gen(i) * l[i];
    }
    return (v);
}

proc leadcoef_X(poly P) {
    def BR = basering;
    setring(@R);

    def P = imap(BR, P);
    poly c = leadcoef(P);
    setring(BR);
    def c = imap(@R, c);
    return (c);
}

proc lpp_X(poly P) {
    def BR = basering;

    setring(@R);
    def P = imap(BR, P);
    def m = leadmonom(P);

    setring(BR);
    def m = imap(@R, m);
    return (m);
}

proc lm_X(poly P) {
    def BR = basering;
    setring(@R);
    def P = imap(BR, P);

    def T = lead(P);
    setring(BR);
    def T = imap(@R, T);
    return (T);
}
	
proc calculateLPPList(list basis, list null_conds) {
    printf("Now Compute LPP of basis under specialization:");
    def BR = basering;

    setring(@R);
    def basis = imap(BR, basis);
    def null_conds = imap(BR, null_conds);

    int i;

    setring(@RP);
    def null_conds = imap(@R, null_conds);
    vector v;
    list res;
	
    for (i = 1; i <= size(null_conds); i++) {
	v = v + gen(i) * null_conds[i];
    }

    ideal I = radical(ideal(v));
    ideal G = groebner(I);
    int null_flag = 1;

    for (i = 1; i <= size(basis); i++) {
	poly p = basis[i];
	while (p != 0) {
	    if (reduce(leadcoef_X(p), G) == 0) {
	        p = p - lm_X(p);
	    } else {
	        break;
	    }
	}
	if (leadmonom(p) != 0) {
	  res = insert(res, leadmonom(p), size(res));
	  null_flag = 0;
	}
	  
    }

    // Switch back to R[A][X].
    setring(@R);
    if (null_flag) {
      // LPP_{X, A} list is null.
      def res = 0;
    } else {
      // LPP_{X, A} list is not null.
      def res = imap(@RP, res);
      // Get LPP_X list.
      for (i = 1; i <= size(res); i++) {
	res[i] = leadmonom(res[i]);
      }
    }

    setring(BR);
    if (null_flag) {
      def res = 0;
    } else {
      def res = imap(@R, res);
    }
    return(res);
}

// Return 1 if p is essential; otherwise, return 0.
proc Check_Essential(poly p, poly p1, list basis, list null_conds, link out) {
    poly rem;
    list q;
    int i ;

    fprintf(out, newline+"Checking Essential:");
	
    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i]) {
	  fprintf(out, "%s is in MCCGB.", string(p));
	    return (0);
	}
    }
    fprintf(out, "%s is not in MCCGB.", string(p));

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
      fprintf(out, "%s is in the ideal generated by MCCGB.", string(p));
	
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
        vector lpp_basis = listToVec(calculateLPPList(basis, null_conds));
	ideal H = groebner(ideal(lpp_basis));
	fprintf(out, "LPP(P) is %s;", lpp_X(p1));
	fprintf(out, "LPP(MCCGB) is {%s}.", string(ideal(lpp_basis)));
	if (reduce(lpp_X(p1), H) == 0) {
	  fprintf(out, "%s is in the ideal generated by LPP(MCCGB).", string(lpp_X(p1))) ;
	    return (0);
	} else {
	  fprintf(out, "%s is not in the ideal generated by LPP(MCCGB).", string(lpp_X(p1)));
	}
    } else {
      fprintf(out, "%s is not in the ideal generated by MCCGB.", string(p));
    }

    
    // Otherwise, p is essential.
    return (1);
}

proc genMCCGB(Polys, Equ, DisEqu, link out) {

	set_global_rings();

	// Base ring is @R.
	def BR = basering;

        ideal G;
	list modcgs;
	
	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
	
	// Switch to @RP.
	setring(@RP);
	def G = imap(@R, G);
	def modcgs = imap(@R, modcgs);

	fprintf(out, newline + "============================");
	fprintf(out, "Now construct MCCGB:");

	list mccgb;
	int i, j;

	// Add the first branch.
	for (j = 1; j <= size(modcgs[1][3]); j++) {
	    mccgb[j] = modcgs[1][3][j][1] + modcgs[1][3][j][2];
	}
	fprintf(out, newline + "-------------------------");
	fprintf(out, "After adding the first branch:");
	fprintf(out, "MCCGB = {%s}", string(mccgb));

	if (size(modcgs) > 1) {
	    // Consider each branch.
	  fprintf(out, newline + "---------------------");
	  fprintf(out, "Consider each branch:" + newline);
	    for (i = 2; i <= size(modcgs); i++) {
		list null_conds;
	        fprintf(out, newline+"Coming to Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

	        // If Groebner Basis of the branch is empty, then pass.
	        if (size(modcgs[i][3]) != 0) {
		    // Build the list of null conditions.
	            for (j = 1; j <= size(modcgs[i][1]); j++) {
			null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	            }

	            // For each polynomial in the Groebner Basis.
	            for (j = 1; j <= size(modcgs[i][3]); j++) {
			poly p1 = modcgs[i][3][j][1];
	                poly p0 = modcgs[i][3][j][2];
	                poly p = p1 + p0;

	                fprintf(out, newline+"Currently consider polynomial P = %s.", string(p));

	                if (Check_Essential(p, p1, mccgb, null_conds, out) == 1) {
			    // p is essential, add to mccgb.
			  fprintf(out, "%s is essential.", string(p));
	                  mccgb = insert(mccgb, p, size(mccgb));
	                } else {
			  fprintf(out, "%s is not essential.", string(p));
			}
	            } 
	        }

	    }
	}

	// Switch back to @R.
	setring(BR);
	def mccgb = imap(@RP, mccgb);
	def G = imap(@RP, G);
	def modcgs = imap(@RP, modcgs);

	fprintf(out, newline + "================================");
	

	return(mccgb, G, modcgs);
}

proc showMCCGB(list mccgb, link out) {
    int i;

    fprintf(out, "The MCCGB is:" + newline );
    if (size(mccgb) == 0) {
        fprintf(out, "{  }." + newline);
    } else {
	for (i = 1; i < size(mccgb); i++) {
	    fprintf(out, "%s,", mccgb[i]);
	}
	fprintf(out, "%s." + newline, mccgb[size(mccgb)]);
    }
}

proc get_nonzero_part(list l) {
    int i;
    list res_list;

    for (i = 1; i <= size(l); i++) {
	res_list[i] = l[i][1];
    }

    return (res_list);
}

proc verify_with_nonnull(poly p, list nonnull_conds) {
  // Base ring is Q[X, A].

  // If nonnull_conds is null.
  if (size(nonnull_conds) == 0) {
    // Only 1 is in N.
    ideal tempN = radical(1);
    if (reduce(p, tempN) == 0) {
      return (p);
    } else {
      return (0);
    }
  }

  int i;
  for (i = 1; i <= size(nonnull_conds); i++) {
    // 1 is naturally in N.
    ideal tempN = radical(nonnull_conds[i], 1);
    if (reduce(p, tempN) == 0) {
      return (p);
    }
  }

  return (0);
}

proc get_sigma_basis(list basis, list null_conds, list nonnull_conds, int flag) 
"USAGE:    Get the basis under the specialization set by null_conds.
           If flag != 0, then basis is from CGS, which needs to eliminate
           auxiliary variables first.
RETURN:    Basis under the given specialization."
{
  int i;
  if (flag) {

    for (i = 1; i <= size(basis); i++) {
      basis[i] = basis[i][1] + basis[i][2];
    }
  }

  //if (size(null_conds) == 0) {
  //  return (basis);
  //}

  // Switch to Q[X, A].
  def BR = basering;
  setring(@RP);
  def basis = imap(BR, basis);

  // Copy null_conds to Q[X, A].
  if (!defined(null_conds)) {
    def null_conds = imap(BR, null_conds);
  } else {
    if (size(null_conds) > 0) {
      def null_conds = imap(BR, null_conds);
    }
  }

  // Copy nonnull_conds to Q[X, A].
  if (!defined(nonnull_conds)) {
    def nonnull_conds = imap(BR, nonnull_conds);
  } else {
    if (size(nonnull_conds) > 0) {
      def nonnull_conds = imap(BR, nonnull_conds);
    }
  }


  vector v;
  list sigma_basis;

  if (size(null_conds) > 0) {
    for (i = 1; i <= size(null_conds); i++) {
      v = v + gen(i) * null_conds[i];
    }
  }

  ideal E = radical(ideal(v));
  ideal GE = groebner(E);

  for (i = 1; i <= size(basis); i++) {
    poly p = basis[i];
    poly p1 = 0;
    while (p != 0) {
      def rem = reduce(leadcoef_X(p), GE);
      if (rem != 0) {
        // Yiming Begin: test whether rem  != 0 wrt ideal N.
	//rem = verify_with_nonnull(rem, nonnull_conds);
	// Yiming End.
	p1 = p1 + rem * lpp_X(p);
      }
      p = p - lm_X(p);
    } // End of while.
    if (p1 != 0) {
      sigma_basis = insert(sigma_basis, p1, size(sigma_basis));
    }
  } // End of for.

  // The case that sigma(basis) is empty should be processed specially.
  int empty_flag = size(sigma_basis);

  // Switch back to Q[A][X].
  setring(BR);
  if (empty_flag == 0) {
    def sigma_basis = 0;
  } else {
    def sigma_basis = imap(@RP, sigma_basis);
  }

  return (sigma_basis);
}

proc check_ideal_equality(list g1, list g2, ideal E) 
"USAGE:    Check whether ideals <g1> and <g2> are equivalent.
RETURN:    1 if they are equivalent; 0 otherwise."
{
  // Basering is Q[A][X].
  def I_ideal_equality = groebner(ideal(listToVec(g1)));
  def J_ideal_equality = groebner(ideal(listToVec(g2)));
  int i;
  int flag = 1;
  poly rem_ideal_equality;

  for (i = 1; i <= size(g1); i++) {
    rem_ideal_equality = reduce(g1[i], J_ideal_equality);
    if (rem_ideal_equality != 0) {
      // If remainder is not 0,
      // then switch to Q[X, A].
      rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
      setring(@RP);
      def J_ideal_equality = imap(@R, J_ideal_equality);
      def rem_ideal_equality = imap(@R, rem_ideal_equality);
      def E = imap(@R, E);

      // Check whether rem can be reduced to 0 under radical of E.
      if (!rad_con(rem_ideal_equality, E)) {
      	 flag = 0;
	 setring(@R);
	 break;
      } else {
         setring(@R);
      }

    }
  }


  if (flag != 0) {
    for (i = 1; i <= size(g2); i++) {
      rem_ideal_equality = reduce(g2[i], I_ideal_equality);
      if (rem_ideal_equality != 0) {
        // If rem is not 0, switch to Q[X, A].
	rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
	setring(@RP);
	def I_ideal_equality = imap(@R, I_ideal_equality);
	def rem_ideal_equality = imap(@R, rem_ideal_equality);
	def E = imap(@R, E);

	// Check whether rem can be reduced to 0 under radical of E.
	if (!rad_con(rem_ideal_equality, E)) {
	  flag = 0;
	  setring(@R);
	  break;
	} else {
	  setring(@R);
	}
      }
    }
  }


  return (flag);
}

proc check_comprehensiveness(list basis, list modcgs, link out) 
"USAGE:    Check whether mccgb is a comprehensive Groebner basis for the given CGS modcgs.
RETURN:    1 if mccgb is CGB; 0 otherwise."
{
  int i;
  int num_branches = size(modcgs);

  // For each branch ((E_i, N_i), G_i).
  for (i = 1; i <= num_branches; i++) {
    fprintf(out, newline + "  Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

    // Get list of null conditions.
    int j;
    list null_conds;

    if (size(modcgs[i][1]) == 0) {
      null_conds = list();
    } else {
      for (j = 1; j <= size(modcgs[i][1]); j++) {
        null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
      }
    }

    // Consider G_i.
    if (size(modcgs[i][3]) != 0) {
      // G_i is not empty.

      // Get sigma(G_i) and sigma(basis).
      if (size(null_conds) == 0) {
	// The null condition set is empty.
	def sigma_g = get_nonzero_part(modcgs[i][3]);
	//def sigma_g = get_sigma_basis(modcgs[i][3], null_conds, modcgs[i][2], 1);
	//def sigma_basis = basis;
      } else {
	// The null condition set is not empty.	
	def sigma_g = get_sigma_basis(modcgs[i][3], null_conds, modcgs[i][2], 1);
	//def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      }
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      
      fprintf(out, "    sigma(G_%s) = {%s};", string(i), string(sigma_g));
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));
    
      // Check whether sigma(basis) is a Groebner basis.
      if (check_groebner(sigma_basis, modcgs[i][1], modcgs[i][2])) {
	// Check whether <sigma(basis)> = <sigma(g)>.
	if (check_ideal_equality(sigma_g, sigma_basis, modcgs[i][1])) {
	  fprintf(out, "  sigma(basis) is GB for Branch %s.", string(i));
	} else {
	  fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
	  return (0);
	}
      } else {
	fprintf(out, "  sigma(basis) is not even a GB.", string(i));
	return (0);
      }
  
    } else {
      // G_i is empty.
      fprintf(out, "    G_%s is empty;", string(i));
      
      // Get sigma_basis.
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));

      if (sigma_basis[1] == 0) {
	fprintf(out, "  sigma(basis) is GB for Branch %s.", string(i));
      } else {
	fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
	return (0);
      }


    } // End of if.
  } // End of for.

  return (1);
} // End of proc.

proc gen_sub_list(list l) 
"USAGE:    Generate all the largest proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  list res_list;
  
  if (size(l) != 0 && size(l) != 1) {
    for (i = 1; i <= size(l); i++) {
      list k;
      for (j = 1; j <= size(l); j++) {
	if (i != j) {
	  k = insert(k, l[j], size(k));
	}
      }
      res_list[i] = k;
    }
  } // End of if.

  return (res_list);
}

proc get_coef_list(poly f) 
"USAGE:    Given parametric polynomial f in Q[A][X], 
           get the coefficients (only numerators) of all its monomials as list."
{
  // Base ring is Q[A][X].
  list res_list;

  while (f != 0) {
    poly lc = leadcoef(f);
    lc = lc * denominator(number(lc));
    res_list = insert(res_list, lc, size(res_list));

    f = f - lead(f);
  }

  return (res_list);
}

proc check_coef_list_null(list coef_list, ideal E, list nonnull_conds) {
  // Base ring is Q[X, A].

  if (size(coef_list) == 0) {
    return (1);
  }

  // General Case.
  int i;
  int flag = 1;
  poly cur_coef;

  for (i = 1; i <= size(coef_list); i++) {
    cur_coef = coef_list[i];

    if (!rad_con(cur_coef, E)) {
      // cur_coef is not reduced to 0 under E.
      // Further check: whether cur_coef is determined to be non-zero under nonnull_conds.
      if (verify_with_nonnull(cur_coef, nonnull_conds) != 0) {
        flag = 0;
	break;
      }
    }
  }

  return (flag);
}

proc check_groebner(list basis, ideal E, list nonnull_conds) {
  // Basering is Q[A][X].
  if (size(basis) <= 1) {
    return(1);
  }

  int i, j;
  poly rem_check_groebner;
  ideal G_check_groebner = ideal(listToVec(basis));

  for (i = 1; i <= size(basis); i++) {
    for (j = 1; j <= size(basis); j++) {
      if (i != j) {
	poly f = spoly(basis[i], basis[j]);
	rem_check_groebner = reduce(f, G_check_groebner);
	if (rem_check_groebner != 0) {
	  // If the remainder is not 0, then switch to Q[X, A].
	  def coef_list = get_coef_list(rem_check_groebner);
	  setring(@RP);
	  def G_check_groebner = imap(@R, G_check_groebner);
	  def coef_list = imap(@R, coef_list);
	  def E = imap(@R, E);
	  
	  if (!defined(nonnull_conds)) {
	    def nonnull_conds = imap(@R, nonnull_conds);
	  } else {
	    if (size(nonnull_conds) > 0) {
	      def nonnull_conds = imap(@R, nonnull_conds);
	    }
	  }
	  
	  // Check whether the remainder can be reduced to 0 under radical of E.
	  if (check_coef_list_null(coef_list, E, nonnull_conds)) {
	    setring(@R);
	  } else {
	    printf("S-Poly(f_%s, f_%s) mod G != 0.", string(i), string(j));
	    setring(@R);
	    return (0);
	  }

	}
      }
    }
  }

  return (1);
}

proc check_minimality(list cgb, list modcgs, link out) 
"USAGE:    Check whether cgb is minimal, given that it is already comprehensive.
RETURN:    1 if cgb is minimal; 0 otherwise."
{
  if (size(cgb) <= 1) {
    fprintf(out, "MCCGB is minimal!");
    return (1);
  }

  list sub_sets = gen_sub_list(cgb);
  int i;

  // For each largest proper subset of cgb.
  for (i = 1; i <= size(sub_sets); i++) {
    fprintf(out, newline + "%s.  Now Check the subset MCCGB \\ {f_%s}:", string(i), string(i));
    if (check_comprehensiveness(sub_sets[i], modcgs, out)) {
	// If the current proper subset of cgb is also a CGB,
        //  then cgb is not minimal.
        fprintf(out, "The subset MCCGB \\ {f_%s} is also CGB.", string(i));
	return (0);
    }
  }

  return (1);
}

proc check_validity(list mccgb, list modcgs, link out) 
"USAGE:    Check whether mccgb is minimal and comprehensive for the given CGS modcgs.
RETURN:    A string denoting why mccgb is not MCCGB;
           An integer flag denoting whether mccgb is valid (return (1)) or not (return (0)).
EXAMPLE:   (err_msg, flag) = check_validity(mccgb, Modcgs);"
{
  fprintf(out, newline + "===================================");
  fprintf(out, "Now check whether MCCGB is comprehensive and minimal:");
  fprintf(out, "-----------------");

  fprintf(out, "First, check the comprehensiveness of MCCGB:" + newline);

  if (check_comprehensiveness(mccgb, modcgs, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "MCCGB is comprehensive.");
    fprintf(out, newline + "------------------------");
    fprintf(out, "Second, check the minimality of MCCGB:");
    if (check_minimality(mccgb, modcgs, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "MCCGB is minimal.");
      return ("", 1);

    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "MCCGB is not minimal.");
      return ("it is not minimal", 0);
    }

  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "MCCGB is not comprehensive.");
    return ("it is not comprehensive", 0);
  }

}
