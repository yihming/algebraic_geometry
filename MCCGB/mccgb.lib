LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.lib";

proc set_global_rings_mccgb() {
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);

  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;
  show(@RP);

  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);
  setring(BR);
	
}
	
proc listToVec(list l) {
    vector v;
    int i;

    if (size(l) == 0) {
      return (vector(0));
    }

    for (i = 1; i <= size(l); i++) {
	v = v + gen(i) * l[i];
    }
    return (v);
}

proc vecToList(vector v) {
  list l;
  int i;
  
  if (size(v) == 0) {
    return list();
  }

  for (i = 1; i <= size(v); i++) {
    l[i] = v[i];
  }

  return (l);
}

proc leadcoef_X(poly P) {
    def BR = basering;
    setring(@R);

    def P = imap(BR, P);
    poly c = leadcoef(P);
    setring(BR);
    def c = imap(@R, c);
    return (c);
}

proc lpp_X(poly P) {
    def BR = basering;

    setring(@R);
    def P = imap(BR, P);
    def m = leadmonom(P);

    setring(BR);
    def m = imap(@R, m);
    return (m);
}

proc lm_X(poly P) {
    def BR = basering;
    setring(@R);
    def P = imap(BR, P);

    def T = lead(P);
    setring(BR);
    def T = imap(@R, T);
    return (T);
}
	
proc calculateLPPList(list basis, ideal E, list N) {
  // Base ring is @RP.
    printf("Now Compute LPP of basis under specialization:");

    if (size(basis) == 0) {
      return (list(0));
    }

    int i;
    vector v;
    list res;

    ideal I = radical(E);
    ideal G = groebner(I);

    
    for (i = 1; i <= size(basis); i++) {
	poly p = basis[i];
	while (p != 0) {
	  poly lcxP = leadcoef_X(p);

	  if (reduce(lcxP, G) == 0) {
	    // LC_X(p) = 0.
	    p = p - lm_X(p);
	  } else {
	    // LC_X(p) != 0.
	    // Further check: whether LC_X(p) is guaranteed to be non-zero by N.
	    if (verify_with_nonnull(lcxP, N) != 0) {
	      // LC_X(p) is guaranteed to be non-zero.
	      break;
	    } else {
	      // LC_X(p) can be zero under some specialization of this branch.
	      p = p - lm_X(p);
	    }
	  }
	}

	// Add LPP_X(p) to the result list if valid.
	if (leadmonom(p) != 0) {
	  res = insert(res, lpp_X(p), size(res));
	}
	  
    }

    return(res);
}

// Return 1 if p is essential; otherwise, return 0.
proc Check_Essential(poly p, poly p1, list basis, ideal E, list N, link out) {
    poly rem;
    list q;
    int i ;

    fprintf(out, newline+"Checking Essential:");
	
    // If p is already in the basis, then it's non-essential.
    for (i = 1; i <= size(basis); i++) {
	if (p == basis[i]) {
	  fprintf(out, "%s is in MCCGB.", string(p));
	    return (0);
	}
    }
    fprintf(out, "%s is not in MCCGB.", string(p));

    // Otherwise, judge whether it's in the ideal generated by basis.
    vector v;
    for (i = 1; i <= size(basis); i++) {
        v = v + gen(i) * basis[i];
    }
    ideal G = groebner(ideal(v));
    rem = reduce(p, G);
	
    if (rem == 0) {
      fprintf(out, "%s is in the ideal generated by MCCGB.", string(p));
	
	// Further, test under the current specialization,
	// whether its LPP is in the ideal generated by LPP's of basis.
      vector lpp_basis = listToVec(calculateLPPList(basis, E, N));
	ideal H = groebner(ideal(lpp_basis));
	fprintf(out, "LPP(P) is %s;", lpp_X(p1));
	fprintf(out, "LPP(MCCGB) is {%s}.", string(ideal(lpp_basis)));
	if (reduce(lpp_X(p1), H) == 0) {
	  fprintf(out, "%s is in the ideal generated by LPP(MCCGB).", string(lpp_X(p1))) ;
	    return (0);
	} else {
	  fprintf(out, "%s is not in the ideal generated by LPP(MCCGB).", string(lpp_X(p1)));
	}
    } else {
      fprintf(out, "%s is not in the ideal generated by MCCGB.", string(p));
    }

    
    // Otherwise, p is essential.
    return (1);
}

proc listDeleteByPoly(list l, poly f) {
  int i;
  if (size(l) == 0) {
    return (list());
  } else {
    for (i = 1; i <= size(l); i++) {
      if (l[i] == f || l[i] == -f) {
	return (delete(l, i));
      }
    }
    return (l);
  }
}

proc appearInBranch(poly f, list branch) {
  // Basering is @RP.
  if (size(branch[3]) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(branch[3]); i++) {
      poly g = branch[3][i][1] + branch[3][i][2];
      if (g == f) {
	return (1);
      }
    }
    return (0);
  }
}

proc genPPs(poly f) {
  // Basering is @RP.
  if (f == 0) {
    return (list(0));
  } else {
    list res_list;
    while(f != 0) {
      res_list = insert(res_list, lpp_X(f), size(res_list));
      f = f - lm_X(f);
    }
    return (res_list);
  }
}

proc checkCoefZero(poly c, ideal E) {
  // Basering is @RP.
  ideal GE = radical(E);
  
  poly rem = reduce(c, GE);
  if (rem == 0) {
    return (1);
  } else {
    return (0);
  }

  
}

proc getCoefOfPP(poly pp, poly f) {
  // Basering is @RP.
  poly c;
  while (f != 0) {
    if (lpp_X(f) == pp) {
      c = leadcoef_X(f);
      break;
    } else {
      f = f - lm_X(f);
    }
  }

  return (c);
}

proc listContains(poly f, list l) {
  if (size(l) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(l); i++) {
      if (f == l[i] || -f == l[i]) {
	return (1);
      }
    }
    return (0);
  }
}

proc genCandidatePolys(poly lpp_f, list G, ideal E) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  } else {
    int i;
    list res_list;
    for (i = 1; i <= size(G); i++) {
      poly g = G[i];
      if (listContains(lpp_f, genPPs(g))) {
	poly c = getCoefOfPP(lpp_f, g);
	if (!checkCoefZero(c, E)) {
	  res_list = insert(res_list, g, size(res_list));
	}
      } // Endif.
    } // Endfor.
    return (res_list);
  } // Endif.
}

proc genConfigByPoly(poly pp, poly g) {
  // Basering is @RP.
  
  // Construct E.
  list null_conds;
  poly f = g;
  while (lpp_X(f) != pp) {
    poly c = leadcoef_X(f);
    null_conds = insert(null_conds, c, size(null_conds));
    f = f - lm_X(f);
  }
  def E = ideal(listToVec(null_conds));

  // Construct N.
  poly nonnull_cond = getCoefOfPP(pp, g);
  
  return (E, list(nonnull_cond));
}

proc checkConfigConsistency(ideal E, list N) {
  // Switch to @AXU.
  vector N_vec = listToVec(N);
  def BR = basering;
  setring(@AXU);

  def E = imap(@RP, E);

  def N_vec = imap(@RP, N_vec);
  list N_raw = vecToList(N_vec);

  // Remove 0's from N.
  list N;
  for (i = 1; i<= size(N_raw); i++) {
    if (N_raw[i] != 0) {
      N = insert(N, N_raw[i], size(N));
    }
  }
  
  if (Check_Consistence_CGB(E, N)) {
    setring(BR);
    return (1);
  } else {
    setring(BR);
    return (0);
  }
}

// Warning: the correctness of the method used here is not proved.
proc checkConfigUnionWithBranch(list config_list, ideal E, list N) {
  // Basering is @RP.
  if (size(config_list) == 0) {
    return (0);
  }

  int i, j;
  poly null_prod = 1;
  poly nonnull_prod = 1;
  for (i = 1; i <= size(config_list); i++) {
    if (size(config_list[i][1]) != 0) {
      for (j = 1; j <= size(config_list[i][1]); j++) {
	null_prod = null_prod * config_list[i][1][j];
      }
    }
    
    for (j = 1; j <= size(config_list[i][2]); j++) {
      nonnull_prod = nonnull_prod * config_list[i][2][j];
    }
  }

  // Factorize both of the products.
  ideal null_FL = factorize(null_prod, 1);
  ideal nonnull_FL = factorize(nonnull_prod, 1);

  // One direction: for each poly in null_FL but not in E,
  // check whether its corresponding poly is in nonnull_FL. 
  ideal GE = radical(E);
  for (i = 1; i <= size(null_FL); i++) {
    poly cur_factor = null_FL[i];
    if (reduce(cur_factor, GE) != 0) {
      if (reduce(cur_factor, nonnull_FL) != 0) {
	return (0);
      }
    }
  }

  // Backward: for each poly in nonnull_FL but not in N,
  // check whether its corresponding poly is in null_FL.
  for (i = 1; i <= size(nonnull_FL); i++) {
    poly cur_factor = nonnull_FL[i];
    if (!listContains(cur_factor, N)) {
      if (reduce(cur_factor, null_FL) != 0) {
	return (0);
      }
    }
  }

  return (1);
}

// Used for top-down algorithm.
proc checkEssential(poly g, list G, list modcgs, link out) {
  // Basering is @RP.
  int i, j;
  
  if (size(modcgs) == 0) {
    return (1);
  }

  for (i = 1; i <= size(modcgs); i++) {
    // For each branch in which g appears.
    if (appearInBranch(g, modcgs[i])) {
      // G_i is guaranteed to be non-empty.
      // Compute LPP_X(sigma(g)).
      poly lpp_g;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (g == modcgs[i][3][j][1] + modcgs[i][3][j][2]) {
	  lpp_g = lpp_X(modcgs[i][3][j][1]);
	}
      }
      list candidates = genCandidatePolys(lpp_g, G, modcgs[i][1]);
      if (size(candidates) == 0) {
	// There is no other poly covering g's LPP_X.
	// So g is essential.
	fprintf(out, "%s is essential in Branch %s.", string(g), string(i));
	return (1);
      } 
      
      list config_list;
      for (j = 1; j <= size(candidates); j++) {
	// For each poly in candidates.
	ideal subE;
	list subN;
	(subE, subN) = genConfigByPoly(lpp_g, candidates[j]);
	ideal newE = modcgs[i][1] + subE;
	list newN = modcgs[i][2] + subN;
	// If this configuration is consistent with both itself and branch config.
	// Then add it to config_list.
	if (checkConfigConsistency(newE, newN)) {
	  list config = subE, subN;
	  config_list = insert(config_list, config, size(config_list));
	}

	
      } // Endfor.

      // Check whether union of config_list is exactly (E_i, N_i).
      if (checkConfigUnionWithBranch(config_list, modcgs[i][1], modcgs[i][2])) {
	// If so, then g is covered by other polys in any sigma of Branch i.
	// Then g is non-essential here.
	fprintf(out, "%s is not essential in Branch %s.", string(g), string(i));
      } else {
	// Otherwise, g is essential for Branch i, thus essential globally.
	fprintf(out, "%s is essential in Branch %s.", string(g), string(i));
	return (1);
      } // Endif.

    } // Endif.
  } // Endfor.
  
  // Now g is non-essential for all branches in which it appears.
  // Thus g is non-essential globally.
  return (0);
}

proc printListToFile(list l, link out) {
  if (size(l) == 0) {
    fprintf(out, newline);
  } else {
    int i;

    for (i = 1; i<= size(l); i++) {
      fprintf(out, "%s,", l[i]);
    }
  }
}

proc genMCCGB_topdown(ideal Polys, ideal Equ, list DisEqu, link out) {
  // Basering is @R.
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
  set_global_rings_mccgb();

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);
  def modcgs = imap(@R, modcgs);

  fprintf(out, newline + "======================");
  fprintf(out, "Now remove non-essential poly:");

  list mccgb;
  int i, j;

  // Initially, set G to be mccgb.
  for (i = 1; i <= size(G); i++) {
    mccgb[i] = G[i];
  }
  fprintf(out, "Initially, M = {%s}", string(mccgb));

  // For each poly in mccgb.
  for (i = 1; i <= size(G); i++) {
    poly cur_g = G[i];
    fprintf(out, "-------------------------------------");
    fprintf(out, "Now consider %s:", string(cur_g));
    mccgb = listDeleteByPoly(mccgb, cur_g);
    fprintf(out, "M' = {");
    printListToFile(mccgb, out);
    fprintf(out, "}.");
    
    if (checkEssential(cur_g, mccgb, modcgs, out)) {
      fprintf(out, "%s is essential.", string(cur_g));
      mccgb = insert(mccgb, cur_g, size(mccgb)); 
    } else {
      fprintf(out, "%s is not essential.", string(cur_g));
    }
  }

  // Switch back to @R.
  setring(@R);
  def mccgb = imap(@RP, mccgb);
  def G = imap(@RP, G);
  def modcgs = imap(@RP, modcgs);

  fprintf(out ,newline + "=================================");

  return (mccgb, G, modcgs);
     
}

proc genMCCGB(ideal Polys, ideal Equ, list DisEqu, link out) {


	// Base ring is @R.

        ideal G;
	list modcgs;
	
	(G, modcgs) = cgb_mod(Polys, Equ, DisEqu, out);
	set_global_rings_mccgb();


	// Switch to @RP.
	setring(@RP);
	def G = imap(@R, G);
	def modcgs = imap(@R, modcgs);

	fprintf(out, newline + "============================");
	fprintf(out, "Now construct MCCGB:");

	list mccgb;
	int i, j;

	// Add the first branch.
	for (j = 1; j <= size(modcgs[1][3]); j++) {
	    mccgb[j] = modcgs[1][3][j][1] + modcgs[1][3][j][2];
	}
	fprintf(out, newline + "-------------------------");
	fprintf(out, "After adding the first branch:");
	fprintf(out, "MCCGB = {%s}", string(mccgb));

	if (size(modcgs) > 1) {
	    // Consider each branch.
	  fprintf(out, newline + "---------------------");
	  fprintf(out, "Consider each branch:" + newline);
	    for (i = 2; i <= size(modcgs); i++) {
		list null_conds;
	        fprintf(out, newline+"Coming to Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

	        // If Groebner Basis of the branch is empty, then pass.
	        if (size(modcgs[i][3]) != 0) {
		    // Build the list of null conditions.
	            for (j = 1; j <= size(modcgs[i][1]); j++) {
			null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
	            }

	            // For each polynomial in the Groebner Basis.
	            for (j = 1; j <= size(modcgs[i][3]); j++) {
			poly p1 = modcgs[i][3][j][1];
	                poly p0 = modcgs[i][3][j][2];
	                poly p = p1 + p0;

	                fprintf(out, newline+"Currently consider polynomial P = %s.", string(p));

	                if (Check_Essential(p, p1, mccgb, modcgs[i][1], modcgs[i][2], out) == 1) {
			    // p is essential, add to mccgb.
			  fprintf(out, "%s is essential.", string(p));
	                  mccgb = insert(mccgb, p, size(mccgb));
	                } else {
			  fprintf(out, "%s is not essential.", string(p));
			}
	            } 
	        }

	    }
	}

	// Switch back to @R.
	setring(@R);
	def mccgb = imap(@RP, mccgb);
	def G = imap(@RP, G);
	def modcgs = imap(@RP, modcgs);

	fprintf(out, newline + "================================");
	

	return(mccgb, G, modcgs);
}

proc showMCCGB(list mccgb, link out) {
    int i;

    fprintf(out, "The MCCGB is:" + newline );
    if (size(mccgb) == 0) {
        fprintf(out, "{  }." + newline);
    } else {
	for (i = 1; i < size(mccgb); i++) {
	    fprintf(out, "%s,", mccgb[i]);
	}
	fprintf(out, "%s." + newline, mccgb[size(mccgb)]);
    }
}

proc get_nonzero_part(list l) {
    int i;
    list res_list;

    for (i = 1; i <= size(l); i++) {
	res_list[i] = l[i][1];
    }

    return (res_list);
}

proc is_sublist(list l1, list l2) 
"INPUT:    l1, l2 are two lists with identical structures. 
           Take l1 as an example, l1[1] is a list of poly factors,
           l1[2] is the list of degrees for the corresponding factor in l1[1]"
{
  // Base ring is Q[X, A].
  int i, j;

  int N1 = size(l1[1]);
  int N2 = size(l2[1]);

  if (N1 == 0) {
    return (1);
  } else {
    if (N2 == 0) {
      return (0);
    }
  }

  // General case.
  int cnt = 0;
  for (i = 1; i <= size(l1[1]); i++) {
    for (j = 1; j <= size(l2[1]); j++) {
      // l1[1][i] = {+1, -1} * l2[1][j]
      if (l1[1][i] == l2[1][j] || l1[1][i] == -l2[1][j]) {
	cnt = cnt + 1;
	break;
      }
    }
  }

  if (cnt == N1) {
    return (1);
  } else {
    return (0);
  }

}

proc verify_with_nonnull(poly p, list nonnull_conds) 
"USAGE:    Judge whether p is determined to be non-zero or not.
INPUT:     p -- Polynomial in Q[A], which is usually LC_A(t) for 
                some monomial t in poly f.
RETURN:    0 if not determined to be non-zero; p itself otherwise."
{
  // Base ring is Q[X, A].

  // If nonnull_conds is null.
  if (size(nonnull_conds) == 0) {
    // Only 1 is in N, i.e. every leading coefficient is non-zero.
    return (p);
  }

  if (leadmonom(p) == 1) {
    // p is a constant, i.e. p is enforced to be non-zero.
    return (p);
  }

  // Multiply each poly in nonnull_conds.
  poly n_poly = 1;
  int i;
  for (i = 1; i <= size(nonnull_conds); i++) {
    n_poly = n_poly * nonnull_conds[i];
  }

  // Factorize the product n_poly and p. We only care about non-constant factors with no multiplicity.
  list FL = factorize(n_poly, 1);
  list LCFL = factorize(p, 1);

  if (is_sublist(LCFL, FL)) {
    // LCFL is a subset of FL.
    return (p);
  }

  return (0);
}

proc is_poly_nonnull(poly f, list nonnull_conds) 
"RETURN:    1 if some of the coefficients of f is enforced to be non-zero under nonnull_conds;
            0 otherwise."
{
  // Base ring is Q[X, A].

  if (size(nonnull_conds) == 0) {
    // Everything is enforced to be non-zero.
    return (1);
  }
 
  
  list coef_list = get_coef_list(f);
  if (size(coef_list) == 0) {
    return (0);
  } else {
    int i;
    int null_cnt = 0;
    for (i = 1; i <= size(coef_list); i++) {
      poly cur_coef = coef_list[i];
      if (verify_with_nonnull(cur_coef, nonnull_conds) == 0) {
	// cur_coef is not enforced to be non-zero.
	null_cnt = null_cnt + 1;
      }
    }
    if (null_cnt == size(coef_list)) {
      // Each coefficient is not enforced to be non-zero. Thus, we can regard f -> 0.
      return (0);
    } else {
      return (1);
    }
  }

}

proc get_sigma_basis(list basis, list null_conds, list nonnull_conds, int flag) 
"USAGE:    Get the basis under the specialization set by null_conds.
           If flag != 0, then basis is from CGS, which needs to eliminate
           auxiliary variables first.
RETURN:    Basis under the given specialization."
{
  int i;
  if (flag) {

    for (i = 1; i <= size(basis); i++) {
      basis[i] = basis[i][1] + basis[i][2];
    }
  }

  //if (size(null_conds) == 0) {
  //  return (basis);
  //}

  // Switch to Q[X, A].
  def BR = basering;
  setring(@RP);
  def basis = imap(BR, basis);

  // Copy null_conds to Q[X, A].
  if (!defined(null_conds)) {
    def null_conds = imap(BR, null_conds);
  } else {
    if (size(null_conds) > 0) {
      def null_conds = imap(BR, null_conds);
    }
  }

  // Copy nonnull_conds to Q[X, A].
  if (!defined(nonnull_conds)) {
    def nonnull_conds = imap(BR, nonnull_conds);
  } else {
    if (size(nonnull_conds) > 0) {
      def nonnull_conds = imap(BR, nonnull_conds);
    }
  }


  vector v;
  list sigma_basis;

  if (size(null_conds) > 0) {
    for (i = 1; i <= size(null_conds); i++) {
      v = v + gen(i) * null_conds[i];
    }
  }

  ideal E = radical(ideal(v));
  ideal GE = groebner(E);

  for (i = 1; i <= size(basis); i++) {
    poly p = basis[i];
    poly p1 = 0;
    while (p != 0) {
      def rem = reduce(leadcoef_X(p), GE);
      if (rem != 0) {
	p1 = p1 + rem * lpp_X(p);
      }
      p = p - lm_X(p);
    } // End of while.
    if (p1 != 0) {
      // Yiming
      // Further check: whether p1 is enforced to be non-zero w.r.t. N.
      if (is_poly_nonnull(p1, nonnull_conds)) {
	// Some of its coefficients is enforced to be non-zero.
	sigma_basis = insert(sigma_basis, p1, size(sigma_basis));
      }
    }
  } // End of for.

  // The case that sigma(basis) is empty should be processed specially.
  int empty_flag = size(sigma_basis);

  // Switch back to Q[A][X].
  setring(BR);
  if (empty_flag == 0) {
    def sigma_basis = 0;
  } else {
    def sigma_basis = imap(@RP, sigma_basis);
  }

  return (sigma_basis);
}

proc check_ideal_equality(list g1, list g2, ideal E) 
"USAGE:    Check whether ideals <g1> and <g2> are equivalent.
RETURN:    1 if they are equivalent; 0 otherwise."
{
  // Basering is Q[A][X].
  def I_ideal_equality = groebner(ideal(listToVec(g1)));
  def J_ideal_equality = groebner(ideal(listToVec(g2)));
  int i;
  int flag = 1;
  poly rem_ideal_equality;

  for (i = 1; i <= size(g1); i++) {
    rem_ideal_equality = reduce(g1[i], J_ideal_equality);
    if (rem_ideal_equality != 0) {
      // If remainder is not 0,
      // then switch to Q[X, A].
      rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
      setring(@RP);
      def J_ideal_equality = imap(@R, J_ideal_equality);
      def rem_ideal_equality = imap(@R, rem_ideal_equality);
      def E = imap(@R, E);

      // Check whether rem can be reduced to 0 under radical of E.
      if (!rad_con(rem_ideal_equality, E)) {
      	 flag = 0;
	 setring(@R);
	 break;
      } else {
         setring(@R);
      }

    }
  }


  if (flag != 0) {
    for (i = 1; i <= size(g2); i++) {
      rem_ideal_equality = reduce(g2[i], I_ideal_equality);
      if (rem_ideal_equality != 0) {
        // If rem is not 0, switch to Q[X, A].
	rem_ideal_equality = rem_ideal_equality * denominator(number(rem_ideal_equality));
	setring(@RP);
	def I_ideal_equality = imap(@R, I_ideal_equality);
	def rem_ideal_equality = imap(@R, rem_ideal_equality);
	def E = imap(@R, E);

	// Check whether rem can be reduced to 0 under radical of E.
	if (!rad_con(rem_ideal_equality, E)) {
	  flag = 0;
	  setring(@R);
	  break;
	} else {
	  setring(@R);
	}
      }
    }
  }


  return (flag);
}

proc check_comprehensiveness(list basis, list modcgs, link out) 
"USAGE:    Check whether mccgb is a comprehensive Groebner basis for the given CGS modcgs.
RETURN:    1 if mccgb is CGB; 0 otherwise."
{
  int i;
  int num_branches = size(modcgs);

  // For each branch ((E_i, N_i), G_i).
  for (i = 1; i <= num_branches; i++) {
    fprintf(out, newline + "  Branch %s: ({%s}, {%s}):", string(i), string(modcgs[i][1]), string(modcgs[i][2]));

    // Get list of null conditions.
    int j;
    list null_conds;

    if (size(modcgs[i][1]) == 0) {
      null_conds = list();
    } else {
      for (j = 1; j <= size(modcgs[i][1]); j++) {
        null_conds = insert(null_conds, modcgs[i][1][j], size(null_conds));
      }
    }

    // Consider G_i.
    if (size(modcgs[i][3]) != 0) {
      // G_i is not empty.

      // Get sigma(G_i) and sigma(basis).
      if (size(null_conds) == 0) {
	// The null condition set is empty.
	def sigma_g = get_nonzero_part(modcgs[i][3]);
	//def sigma_g = get_sigma_basis(modcgs[i][3], null_conds, modcgs[i][2], 1);
	//def sigma_basis = basis;
      } else {
	// The null condition set is not empty.	
	//def sigma_g = get_sigma_basis(modcgs[i][3], null_conds, modcgs[i][2], 1);
	def sigma_g = get_nonzero_part(modcgs[i][3]);
	//def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      }
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      
      fprintf(out, "    sigma(G_%s) = {%s};", string(i), string(sigma_g));
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));
    
      // Check whether sigma(basis) is a Groebner basis.
      if (check_groebner(sigma_basis, modcgs[i][1])) {
	// Check whether <sigma(basis)> = <sigma(g)>.
	if (check_ideal_equality(sigma_g, sigma_basis, modcgs[i][1])) {
	  fprintf(out, "  sigma(basis) is GB for Branch %s.", string(i));
	} else {
	  fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
	  return (0);
	}
      } else {
	fprintf(out, "  sigma(basis) is not even a GB.", string(i));
	return (0);
      }
  
    } else {
      // G_i is empty.
      fprintf(out, "    G_%s is empty;", string(i));
      
      // Get sigma_basis.
      def sigma_basis = get_sigma_basis(basis, null_conds, modcgs[i][2], 0);
      fprintf(out, "    sigma(basis) = {%s}.", string(sigma_basis));

      if (sigma_basis[1] == 0) {
	fprintf(out, "  sigma(basis) is GB for Branch %s.", string(i));
      } else {
	fprintf(out, "  sigma(basis) is not GB for Branch %s.", string(i));
	return (0);
      }


    } // End of if.
  } // End of for.

  return (1);
} // End of proc.

proc gen_indices(int MaxIdx, int MaxLen) {
  if (MaxIdx <= 0 || MaxLen <= 0) {
    return (list());
  } 

  int i;
  list res_list;
  for (i = 1; i <= MaxLen; i++) {
    res_list = res_list + gen_indices_sub(MaxIdx, i);
  }

  return (res_list);
}

proc gen_indices_sub(int T, int Len) {
  int i, j;
  list res_list;
  if (Len == 1) {
    for (i = 1; i <= T; i++) {
      res_list = insert(res_list, list(i), size(res_list));
    }
    return (res_list);
  }

  list sub_list = gen_indices_sub(T, Len - 1);
  for (i = 1; i <= size(sub_list); i++) {
    list cur_sub_list = sub_list[i];
    int starting_point = cur_sub_list[size(cur_sub_list)] + 1;
   
    if (starting_point <= T){
      for (j = starting_point; j <= T; j++) {
	list l = cur_sub_list;
	l = insert(l, j, size(l));
	res_list = insert(res_list, l, size(res_list));
      }
    }
  }

  return (res_list);
}

proc gen_sub_list(list l, int save_time) 
"USAGE:    Generate all the non-empty proper subsets of l.
RETURN:    A list of lists."
{
  int i, j;
  
  if (save_time) {
    // Only generate the largest proper subsets.
    list index_list = gen_indices_sub(size(l), size(l) - 1);
  } else {
    // Generate all the non-empty proper subsets.
    list index_list = gen_indices(size(l), size(l) - 1);
  }

  if (size(index_list) == 0) {
    return (list());
  }

  // General case.
  list sub_list;
  for (i = 1; i <= size(index_list); i++) {
    list cur_index_list = index_list[i];
    list res_list;
    for (j = 1; j <= size(cur_index_list); j++) {
      res_list = insert(res_list, l[cur_index_list[j]], size(res_list));
    }
    sub_list = insert(sub_list, res_list, size(sub_list));
  }

  return (sub_list);
}

proc get_coef_list(poly f) 
"USAGE:    Given parametric polynomial f in Q[A][X], 
           get the coefficients (only numerators) of all its monomials as list."
{
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def f = imap(BR, f);
  }

  list res_list;

  while (f != 0) {
    poly lc = leadcoef(f);
    lc = lc * denominator(number(lc));
    res_list = insert(res_list, lc, size(res_list));

    f = f - lead(f);
  }

  if (flag == 1) {
    setring(BR);
    def res_list = imap(@R, res_list);
  }

  return (res_list);
}

proc check_coef_list_null(list coef_list, ideal E) 
"RETURN:    1 if all entries in coef_list can be reduced to 0 w.r.t. E.
            0 otherwise."
{
  // Base ring is Q[X, A].

  if (size(coef_list) == 0) {
    return (1);
  }

  int i;
  for (i = 1; i <= size(coef_list); i++) {
    poly cur_coef = coef_list[i];
    if (!rad_con(cur_coef, E)) {
      // cur_coef cannot be reduced to 0 under radical(E).
      return (0);
    }
  }

  return (1);
}

proc check_groebner(list basis, ideal E) {
  // Basering is Q[A][X].
  if (size(basis) <= 1) {
    return(1);
  }

  int i, j;
  poly rem_check_groebner;
  ideal G_check_groebner = ideal(listToVec(basis));

  for (i = 1; i <= size(basis); i++) {
    for (j = 1; j <= size(basis); j++) {
      if (i != j) {
	poly f = spoly(basis[i], basis[j]);
	rem_check_groebner = reduce(f, G_check_groebner);
	if (rem_check_groebner != 0) {
	  // If the remainder is not 0, then switch to Q[X, A].
	  def coef_list = get_coef_list(rem_check_groebner);
	  setring(@RP);
	  def coef_list = imap(@R, coef_list);
	  def E = imap(@R, E);
	  
	  
	  // Check whether the remainder can be reduced to 0 under radical of E.
	  if (!check_coef_list_null(coef_list, E)) {
	    setring(@R);
	    //printf("S-Poly(f_%s, f_%s) mod basis != 0.", string(i), string(j));
	    return (0);
	  } else {
	    setring(@R);
	  }

	}
      }
    }
  }

  return (1);
}



proc check_minimality(list cgb, list modcgs, int save_time, link out) 
"USAGE:    Check whether cgb is minimal, given that it is already comprehensive.
RETURN:    1 if cgb is minimal; 0 otherwise."
{
  if (size(cgb) <= 1) {
    fprintf(out, "MCCGB is minimal!");
    return (1);
  }

  list sub_sets = gen_sub_list(cgb, save_time);

  if (save_time) {
    list idx_lists = gen_indices_sub(size(cgb), size(cgb) - 1);
  } else {
    list idx_lists = gen_indices(size(cgb), size(cgb) - 1);
  }

  int i, j;

  // For each largest proper subset of cgb.
  for (i = 1; i <= size(sub_sets); i++) {
    string subset_str = "{ ";
    list cur_idx_list = idx_lists[i];

    if (size(cur_idx_list) == 1) {
      subset_str = subset_str + "f_{" + string(cur_idx_list[1]) + "}";
    } else {
      for (j = 1; j < size(cur_idx_list); j++) {
	subset_str = subset_str + "f_{" + string(cur_idx_list[j]) + "}, ";
      }
      subset_str = subset_str + "f_{" + string(cur_idx_list[size(cur_idx_list)]) + "}";
    }

    subset_str = subset_str + " }";
    fprintf(out, newline + "%s. Now Check the subset %s", string(i), subset_str);
    if (check_comprehensiveness(sub_sets[i], modcgs, out)) {
	// If the current proper subset of cgb is also a CGB,
        //  then cgb is not minimal.
        fprintf(out, "The subset MCCGB \\ {f_%s} is also CGB.", string(i));
	return (0);
    }
  }

  return (1);
}

proc check_validity(list mccgb, list modcgs, int save_time, link out) 
"USAGE:    Check whether mccgb is minimal and comprehensive for the given CGS modcgs.
RETURN:    A string denoting why mccgb is not MCCGB;
           An integer flag denoting whether mccgb is valid (return (1)) or not (return (0)).
EXAMPLE:   (err_msg, flag) = check_validity(mccgb, Modcgs);"
{
  fprintf(out, newline + "===================================");
  fprintf(out, "Now check whether MCCGB is comprehensive and minimal:");
  fprintf(out, "-----------------");

  fprintf(out, "First, check the comprehensiveness of MCCGB:" + newline);

  if (check_comprehensiveness(mccgb, modcgs, out)) {
    // mccgb is comprehensive, then check the minimality.
    fprintf(out, newline + "MCCGB is comprehensive.");
    fprintf(out, newline + "------------------------");
    fprintf(out, "Second, check the minimality of MCCGB:");
    if (check_minimality(mccgb, modcgs, save_time, out)) {
      // mccgb is also minimal.
      fprintf(out, newline + "MCCGB is minimal.");
      return ("", 1);

    } else {
      // mccgb is not minimal.
      fprintf(out, newline + "MCCGB is not minimal.");
      return ("it is not minimal", 0);
    }

  } else {
    // mccgb is not comprehensive.
    fprintf(out, newline + "MCCGB is not comprehensive.");
    return ("it is not comprehensive", 0);
  }

}

proc alternativeMCCGB(ideal Polys, ideal Equ, list DisEqu, link out) {
  set_global_rings_mccgb();

  // Base ring is @R.
  def BR = basering;

  ideal G_alter;
  list modcgs_alter;

  (G_alter, modcgs_alter) = cgb_mod(Polys, Equ, DisEqu, out);
  // Switch to @RP.
  setring(@RP);
  def G_alter = imap(@R, G_alter);
  def modcgs_alter = imap(@R, modcgs_alter);

  // Initially, mccgb_alter equals to G_alter.
  list mccgb_alter;
  if (size(G_alter) > 0) {
    int i;
    for (i = 1; i <= size(G_alter); i++) {
      mccgb_alter[i] = G_alter[i];
    }
  }

  list Mark;
  // Create the list of occurrances for each poly in mccgb_alter.
  int i, j, k;
  if (size(mccgb_alter) > 0) {
    for (i = 1; i <= size(mccgb_alter); i++) {
      // For each poly in mccgb_alter.
      poly cur_poly = mccgb_alter[i];
      list temp_mark;
      if (size(modcgs_alter) > 0) {
	for (j = 1; j <= size(modcgs_alter); j++) {
	  // For each branch j.
	  if (size(modcgs_alter[j][3]) > 0) {
	    for (k = 1; k <= size(modcgs_alter[j][3]); k++) {
	      // For each g in G_j.
	      poly p = modcgs_alter[j][3][k][1] + modcgs_alter[j][3][k][2];
	      if (cur_poly == p) {
	        temp_mark = insert(temp_mark, j, size(temp_mark));
	      }
	    } // End for k.
	  }
	} // End for j.
      }
      Mark = insert(Mark, temp_mark, size(Mark));
    } // End for i.
  }

  // Remove redundant polys from mccgb_alter.
  int i, j;
  if (size(modcgs_alter) > 0) {
    for (i = 1; i <= size(modcgs_alter); i++) {
      // For each branch.
      if (size(modcgs_alter[i][3]) > 0) {
	for (j = 1; j <= size(modcgs_alter[i][3]); j++) {
	  // For each poly in G_i.
	  poly g = modcgs_alter[i][3][j][1] + modcgs_alter[i][3][j][2];
	  poly g1 = modcgs_alter[i][3][j][1];
	  // Get the index of g (or multiple of g) in mccgb_alter.
	  int idx_g = search_in_list(g, mccgb_alter, 1);
	  // Get LPP_X(sigma(mccgb_alter \ {g})).
	  list l = delete(mccgb_alter, idx_g);
	  vector lpp_basis = listToVec(calculateLPPList(l, modcgs_alter[i][1], modcgs_alter[i][2]));
	  ideal H = groebner(ideal(lpp_basis));
	  if (reduce(lpp_X(g1), H) == 0) {
	    // g is redundant in Branch i.
	    int del_idx = search_in_list(i, Mark[idx_g], 0);
	    Mark[idx_g] = delete(Mark[idx_g], del_idx);
	  }
	}
      }
    }
  }

  if (size(Mark) > 0) {
    int i;
    for (i = size(Mark); i >= 1; i--) {
      // If Mark[i] is empty, remove mccgb_alter[i] from mccgb_alter.
      if (size(Mark[i]) == 0) {
	mccgb_alter = delete(mccgb_alter, i);
      }
    }
  }

  // Switch back to @R.
  setring(BR);
  def mccgb_alter = imap(@RP, mccgb_alter);
  def G_alter = imap(@RP, G_alter);
  def modcgs_alter = imap(@RP, modcgs_alter);

  return (mccgb_alter, G_alter, modcgs_alter);
}

proc search_in_list(poly p, list basis, int multiple_flag) {
  // Base ring is Q[A][X].
  if (size(basis) == 0) {
    return (0);
  }

  int i;
  for (i = 1; i <= size(basis); i++) {
    if (multiple_flag) {
      // Either p or multiple of p occurs.
      ideal I = basis[i];
      if (reduce(p, I) == 0) {
	return (i);
      }
    } else {
      // p occurs.
      if (p == basis[i]) {
	return (i);
      }
    }
  }

  return (0);
}
