LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "cgb_mod.lib";
LIB "buchtrace.lib";
LIB "mcgbcheck.lib";

proc set_global_rings_mcgb() {
  // Basering is K[U][X].

  if (defined(@R)) {
    kill @R;
  }
  if (defined(@P)) {
    kill @P;
  }
  if (defined(@RP)) {
    kill @RP;
  }

  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  string ord_var = Rx[3][1][1];
  Rx[1][3][1][1] = ord_var;

  def @P = ring(Rx[1]);
  
  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;
  
  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);

  setring(BR);
}

proc idealToList(ideal G) {
  if (size(G) == 0) {
    return (list());
  }

  int i;
  list L;
  for (i = 1; i <= size(G); i++) {
    L = insert(L, G[i], size(L));
  }

  return (L);
}

proc listToIdeal(list L) 
{
  if (size(L) == 0) {
    return (ideal());
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def L = imap(BR, L);
    ring_flag = 1;
  }
  
  int i;
  ideal G;
  for (i = 1; i <= size(L); i++) {
    G = G + L[i];
  }

  if (ring_flag) {
    setring BR;
    def G = imap(@RP, G);
  }
  
  return (G);
}

proc ideal_exclude(ideal I, ideal J) {
  // Basering is @RP.
  if (size(I) == 0) {
    return (ideal());
  }


  if (size(J) == 0) {
    return (I);
  }

  poly prod_J = 1;
  int i, j;
  for (i = 1; i <= size(J); i++) {
    prod_J = prod_J * J[i];
  }
  ideal FL_J = factorize(prod_J, 1);

  for (i = 1; i <= size(I); i++) {
    for (j = 1; j <= size(FL_J); j++) {
      if (reduce(I[i], groebner(ideal(FL_J[j]))) == 0) {
	I[i] = I[i] / FL_J[j];
      }
    }
  }

  return (radical(I));
}

proc getNSquareFreeFromProd(poly h) {
  // Basering is @RP.
  ideal FL = factorize(h, 1);
  if (size(FL) == 0) {
    return (list(0));
  }

  int i;
  list res_list;
  for (i = 1; i <= size(FL); i++) {
    res_list = insert(res_list, FL[i], size(res_list));
  }

  return (res_list);
}

proc idealUnion(ideal I, ideal J) {
  // Basering is @RP.
  int i;
  int n = size(I);

  for (i = 1; i <= size(J); i++) {
    I[n + i] = J[i];
  }

  return (I);
}

proc redRepN(ideal E, list N, poly c) {
  // Basering is @RP.
  ideal E_ext = E + ideal(c);
  
  if (Check_Consistence_CGB(E_ext, N)) {
    return (radical(E_ext), N);
  } else {
    return (ideal(1), list(0));
  }
}

proc redRepNN(ideal E, list N, poly c) {
  // Basering is @RP.

  list N_ext = insert(N, c, size(N));

  if (Check_Consistence_CGB(E, N_ext)) {
    poly c_red = reduce(c, groebner(radical(E)));
    list N_ext_red = insert(N, c_red, size(N));
    return (E, N_ext_red);
  } else {
    return (ideal(1), list(0));
  }
}

proc splitBranch(ideal E, list N, poly c) {
  // Basering is @RP.
  list res_list;
  ideal E0;
  list N0;
  (E0, N0) = redRepN(E, N, c);
  list sub1 = E0, N0;
  res_list = insert(res_list, sub1, size(res_list));
  list sub2;
  if (E0[1] == 1) {
    // (E0, N0) is inconsistent.
    sub2 = E, N;
  } else {
    ideal E1;
    list N1;
    (E1, N1) = redRepNN(E, N, c);
    sub2 = E1, N1;
  }
  res_list = insert(res_list, sub2, size(res_list));
  return (res_list);
}


proc checkNull(poly c, ideal E, list N) 
"Check whether c is determined to be 0 under (E, N).
"
{
  // Basering is @RP.
  ideal E_res;
  list N_res;
  (E_res, N_res) = redRepN(E, N, c);

  if (E_res[1] == 1 && N_res[1] == 0) {
    return (0);
  } else {
    // Now need to check if (E, N x {c}) is consistent.
    (E_res, N_res) = redRepNN(E, N, c);
    if (E_res[1] == 1) {
      // c is determined to be 0 under (E, N).
      return (1);
    } else {
     // c is not determined under (E, N).
      return (0);
    }
  }
}


/*
proc checkNull(poly c, ideal E, list N) {
  // Basering is @RP.

  ideal E_rad = radical(E);
  if (reduce(c, groebner(E_rad)) == 0) {
    return (1);
  } else {
    return (0);
  }
}
*/

/*
proc checkNull(poly c, ideal E, list N) {
  // Basering is @RP.
  // (E, N) in R-representation.
  poly Nprod = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    Nprod = Nprod * N[i];
  }

  ideal Ered = radical(ideal_exclude(E, ideal(Nprod)));

  if (reduce(c, groebner(Ered)) == 0) {
    return (1);
  } else {
    return (0);
  }
}
*/

/*
proc checkNullRRep(poly c, ideal E, list N) {
  // Basering is @RP.

  if (reduce(c, groebner(E)) == 0) {
    return (1);
  } 

  return (0);
}
*/

proc checkNonNull(poly c, ideal E, list N) 
"
Check whether c id determined to be non-zero under (E, N).
"
{
  // Basering is @RP.
  ideal E0;
  list N0;
  (E0, N0) = redRepN(E, N, c);
  if (E0[1] == 1) {
    return (1);
  } else { 
    return (0); 
  }
}

proc makeRRepInBranch(ideal E, list N) {
  // Basering is @RP.
  if (size(E) == 0 && size(N) == 0) {
    return (ideal(), list(1));
  }

  ideal newE = radical(E);
  
  poly prod_N = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    prod_N = prod_N * N[i];
  }
  poly prod_N_rem = reduce(prod_N, newE);
  ideal FL_N = factorize(prod_N_rem, 1);

  list newN;
  if (size(FL_N) == 0) {
    newN = 0;
  } else {
    for (i = 1; i <= size(FL_N); i++) {
      newN = insert(newN, FL_N[i], size(newN));
    }
  }

  return (newE, newN);
}

proc paramIdealInsert(ideal E, poly f) {
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def E = imap(BR, E);
    def f = imap(BR, f);
    ring_flag = 1;
  }

  ideal E_new = E + f;

  if (ring_flag) {
    setring BR;
    def E_new = imap(@RP, E_new);
  }

  return (E_new);
}

proc getFactorIdeal(list N) {
  if (size(N) == 0) {
    return (list(1));
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def N = imap(BR, N);
    ring_flag = 1;
  }

  poly N_prod = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    N_prod = N_prod * N[i];
  }

  ideal Factors = factorize(N_prod, 1);

  if (ring_flag) {
    setring BR;
    def Factors = imap(@RP, Factors);
  }

  return (Factors);
}

proc makeRRep(list modcgs) {
  // Basering is @RP.
  list modcgsRed;
  int i;
  for (i = 1; i <= size(modcgs); i++) {
    ideal E;
    list N;
    (E, N) = makeRRepInBranch(modcgs[i][1], modcgs[i][2]);
    list branch = E, N, modcgs[i][3];
    modcgsRed = insert(modcgsRed, branch, size(modcgsRed));
  }

  return (modcgsRed);
}

proc purifyCGB(ideal G) {
  // basering is @R.
  if (size(G) <= 1) {
    return (G);
  }

  G = sortSetAsce(G);
  
  def BR = basering;
  setring @RP;
  
  def G = imap(BR, G);
  list gen_polys = idealToList(G);
  int i = 1;
  int j;

  while (i < size(gen_polys)) {
    j = i + 1;
    while (j <= size(gen_polys)) {
      if (isParametricMultiple(gen_polys[j], gen_polys[i])) {
	gen_polys = delete(gen_polys, j);
      } else {
	j = j + 1;
      }
    }
    i = i + 1;
  }

  ideal G_res = listToIdeal(gen_polys);
  setring BR;
  def G_res = imap(@RP, G_res);
  return (G_res);
}

proc appearsInBranch(poly f, list branch) {
  // Basering is @RP.
  f = f / leadcoef(f);
  if (size(branch[3]) == 0) {
    return (0);
  } 

  ideal E = branch[1];
  list N = branch[2];

  int i;
  for (i = 1; i <= size(branch[3]); i++) {
    poly g = branch[3][i][1] + branch[3][i][2];
    g = g / leadcoef(g);
    if (isParametricMultiple(g, f)) {
      return (1);
    } 
  }

  return (0);
}

proc isParametricMultiple(poly g, poly f) 
"
True if g = c*f, where c belongs to ring @P.
"
{
  int flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    flag = 1;
    def g = imap(BR, g);
    def f = imap(BR, f);
  }

  poly h = g / f;

  if ((g == h * f) && (lppX(h) == 1)) {
    if (flag) {
      setring BR;
    }
    return (1);
  }

  if (flag) {
    setring BR;
  }

  return (0);
}

proc lppX(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def m = leadmonom(P);
  if (flag) {
    setring(BR);
    def m = imap(@R, m);
  }

  return (m);
}

proc leadcoef_U(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }
  poly C = leadcoef(P);
  
  if (flag) {
    setring(BR);
    def C = imap(@R, C);
  }

  return (C);
}

proc lm_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def T = lead(P);
  if (flag) {
    setring(BR);
    def T = imap(@R, T);
  }

  return (T);
}

proc deletePolyFromList(list L, poly f) {
  
  if (size(L) == 0) {
    return (list());
  }

  int i;
  for (i = 1; i <= size(L); i++) {
    if (f == L[i]) {
      L = delete(L, i);
      break;
    }
  }

  return (L);
}

proc delEquivPolyFromList(list L, poly f) {
  // Basering is @RP.
  if (size(L) == 0) {
    return (list());
  }

  int i;
  for (i = 1; i <= size(L); i++) {
    if (equivalent(f, L[i])) {
      L = delete(L, i);
      break;
    }
  }

  return (L);
}

proc getCandidatePolys(poly pp, list M, ideal E, list N) {
  if (size(M) == 0) {
    return (list());
  }

  int i;
  list G_can;
  for (i = 1; i <= size(M); i++) {
    poly cur_g = M[i];
    while (cur_g != 0) {
      if (lppX(cur_g) == pp) {
	// Only consider the coef of pp in M[i].
	if (!checkNull(leadcoef_U(cur_g), E, N)) {
	  // This coef is not determined to be 0 under (E, N).
	  G_can = insert(G_can, M[i], size(G_can));
	  break;
	}
      }
      cur_g = cur_g - lm_X(cur_g);
    }
  }

  return (G_can);
}

proc deletePolyFromG(list G, poly f) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  }

  int i;
  for (i = 1; i <= size(G); i++) {
    if (equivalent(G[i][1] + G[i][2], f)) {
      G = delete(G, i);
      break;
    }
  }

  return (G);
}

proc insertPolyIntoG(list G, poly f, ideal E, list N) {
  // Basering is @RP.
  poly f_null;
  poly f_nonnull;
  
  while (f > 0) {
    poly cur_coef = leadcoef_U(f);
    if (checkNull(cur_coef, E, N)) {
      f_null = f_null + lm_X(f);
    } else {
      poly m_nonnull = reduce(lm_X(f), E);
      poly m_null = lm_X(f) - m_nonnull;
      f_nonnull = f_nonnull + m_nonnull;
      f_null = f_null + m_null;
    }
    f = f - lm_X(f);
  }

  // Make f_nonnull monic.
  poly div_factor = leadcoef(f_nonnull);
  if (div_factor != 1) {
    f_nonnull = f_nonnull / div_factor;
    f_null = f_null / div_factor;
  }

  list l = f_nonnull, f_null;
  G = insert(G, l, size(G));
  return (G);
}

proc lookUpIndex(poly f) {
  // Basering is @RP.
  if (size(CGB) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(CGB); i++) {
      if (CGB[i] == f) {
	return (i);
      }
    }
    return (0);
  }
}

proc checkEssentialByHC(poly f, poly pf, list higher_coefs, poly g, list G_can, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  if (size(higher_coefs) == 0) {
    // {g} covers f in (E, N).
    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));


    if (defined(debug_mode) && debug_mode == 1) {
      int idx_g = lookUpIndex(g);
      int idx_f = lookUpIndex(f);
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  } else {
    int i;
    for (i = 1; i <= size(higher_coefs); i++) {
      poly cur_c = higher_coefs[i];
      
      if (checkNull(cur_c, E, N)) {
	// sigma(cur_c) is always 0.
	i++; // In SINGULAR, we need this statement before continue.
	continue;
      } else {
	if (checkNonNull(cur_c, E, N)) {
	  // sigma(cur_c) is never 0.
	  G_can = deletePolyFromList(G_can, g);
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "There is some non-null higher coef %s. So %s cannot cover %s in (<%s>, {%s})", cur_c, g, f, E, N);
	  }
	  return (checkEssentialInBranch(f, pf, G_can, E, N, G_branch, BL));
	} else {
	  // sigma(cur_c) is not determined.
	  if (defined(debug_mode) && debug_mode >= 1) {
	    fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cur_c);
	  }
	  list branches = splitBranch(E, N, cur_c);
	  int is_essential;
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "Come to sub-branch (<%s> {%s}):", branches[1][1], branches[1][2]);
	  }
	  (is_essential, BL) = checkEssentialInBranch(f, pf, G_can, branches[1][1], branches[1][2], G_branch, BL);
	  if (is_essential) {
	    return (1, BL);
	  } else {
	    G_can = deletePolyFromList(G_can, g);
	    if (defined(debug_mode) && debug_mode == 1) {
	      fprintf(out, "%s is covered in the first sub-branch (<%s>, {%s}).", f, branches[1][1], branches[1][2]);
	      fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
	    }
	    return (checkEssentialInBranch(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
	  }
	}
      }

    }

    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));



    if (defined(debug_mode) && debug_mode == 1) {
      int idx_g = lookUpIndex(g);
      int idx_f = lookUpIndex(f);
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  }
}

proc checkEssentialByHCRandom(poly f, poly pf, list higher_coefs, poly g, list G_can, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  if (size(higher_coefs) == 0) {
    // {g} covers f in (E, N).
    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));



    if (defined(debug_mode) && debug_mode == 1) {
      int idx_g = lookUpIndex(g);
      int idx_f = lookUpIndex(f);
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  } else {
    int i;
    for (i = 1; i <= size(higher_coefs); i++) {
      poly cur_c = higher_coefs[i];
      
      if (checkNull(cur_c, E, N)) {
	// sigma(cur_c) is always 0.
	i++; // In SINGULAR, we need this statement before continue.
	continue;
      } else {
	if (checkNonNull(cur_c, E, N)) {
	  // sigma(cur_c) is never 0.
	  G_can = deletePolyFromList(G_can, g);
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "There is some non-null higher coef %s. So %s cannot cover %s in (<%s>, {%s})", cur_c, g, f, E, N);
	  }
	  return (checkEssentialInBranchRandom(f, pf, G_can, E, N, G_branch, BL));
	} else {
	  // sigma(cur_c) is not determined.
	  if (defined(debug_mode) && debug_mode >= 1) {
	    fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cur_c);
	  }
	  list branches = splitBranch(E, N, cur_c);
	  int is_essential;
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "Come to sub-branch (<%s> {%s}):", branches[1][1], branches[1][2]);
	  }
	  (is_essential, BL) = checkEssentialInBranchRandom(f, pf, G_can, branches[1][1], branches[1][2], G_branch, BL);
	  if (is_essential) {
	    return (1, BL);
	  } else {
	    G_can = deletePolyFromList(G_can, g);
	    if (defined(debug_mode) && debug_mode == 1) {
	      fprintf(out, "%s is covered in the first sub-branch (<%s>, {%s}).", f, branches[1][1], branches[1][2]);
	      fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
	    }
	    return (checkEssentialInBranchRandom(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
	  }
	}
      }

    }

    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));



    if (defined(debug_mode) && debug_mode == 1) {
      int idx_g = lookUpIndex(g);
      int idx_f = lookUpIndex(f);
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  }
}

proc getHigherCoefs(poly f, poly pp) {
  // Basering is @RP.
  list higher_coefs;
  while (lppX(f) > pp) {
    higher_coefs = insert(higher_coefs, leadcoef_U(f), size(higher_coefs));
    f = f - lm_X(f);
  }

  return (higher_coefs);
}

proc getCoefOfPP(poly f, poly pp) {
  // Basering is @RP.
  while (lppX(f) >= pp) {
    if (lppX(f) == pp) {
      return (leadcoef_U(f));
    }
    f = f - lm_X(f);
  }

  return (0);
}
proc checkEssentialInBranch(poly f, poly pf, list MRem, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  MRem = listAsceOrd(MRem);
  list G_can = getCandidatePolys(pf, MRem, E, N);
  if (size(G_can) == 0) {
    list branch = E, N, list(0);
    BL = insert(BL, branch, size(BL));


    if (defined(debug_mode) && debug_mode == 1) {
      int idx_f = lookUpIndex(f);
      fprintf(out, "No subsets of M covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_f), string(f), string(E), string(N));
      fprintf(out, "%s is essential due to (<%s>, {%s}).", f, E, N);
    }
    return (1, BL);
  }

  poly g = G_can[1];
  list higher_coefs = getHigherCoefs(g, pf);
  poly cp = getCoefOfPP(g, pf);
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "Coef(%s, %s) = %s", g, pf, cp);
  }
  if (checkNonNull(cp, E, N)) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Coef(g, pf) is non-null. Now check higher coefs:");
    }
    return (checkEssentialByHC(f, pf, higher_coefs, g, G_can, E, N, G_branch, BL));
  } else {
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cp);
    }
    list branches = splitBranch(E, N, cp);
    int is_essential;
    list G_can_rem = deletePolyFromList(G_can, g);
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Come to sub-branch (<%s>, {%s}):", branches[1][1], branches[1][2]);
    }
    (is_essential, BL) = checkEssentialInBranch(f, pf, G_can_rem, branches[1][1], branches[1][2], G_branch, BL);
    if (is_essential) {
      return (1, BL);
    } else {
      if (defined(debug_mode) && debug_mode >= 1) {
	int idx_f = lookUpIndex(f);
	fprintf(out, "f_%s = %s is covered in the first sub-branch (<%s>, {%s}).", string(idx_f), f, branches[1][1], branches[1][2]);
	fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
      }
      return (checkEssentialInBranch(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
    }
  }
}

proc checkEssentialInBranchRandom(poly f, poly pf, list MRem, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, newline + "Come to locally closed set (<%s>, {%s}):", E, N);
  }

  list G_can = getCandidatePolys(pf, MRem, E, N);
  if (size(G_can) == 0) {
    list branch = E, N, list(0);
    BL = insert(BL, branch, size(BL));


    if (defined(debug_mode) && debug_mode == 1) {
      int idx_f = lookUpIndex(f);
      fprintf(out, "No subsets of M covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_f), string(f), string(E), string(N));
      fprintf(out, "%s is essential due to (<%s>, {%s}).", f, E, N);
    }
    return (1, BL);
  }

  int idx = random(1, size(G_can));
  poly g = G_can[idx];
  list higher_coefs = getHigherCoefs(g, pf);
  poly cp = getCoefOfPP(g, pf);
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "Coef(%s, %s) = %s", g, pf, cp);
  }
  if (checkNonNull(cp, E, N)) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Coef(g, pf) is non-null. Now check higher coefs:");
    }
    return (checkEssentialByHCRandom(f, pf, higher_coefs, g, G_can, E, N, G_branch, BL));
  } else {
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cp);
    }
    list branches = splitBranch(E, N, cp);
    int is_essential;
    list G_can_rem = deletePolyFromList(G_can, g);
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Come to sub-branch (<%s>, {%s}):", branches[1][1], branches[1][2]);
    }
    (is_essential, BL) = checkEssentialInBranchRandom(f, pf, G_can_rem, branches[1][1], branches[1][2], G_branch, BL);
    if (is_essential) {
      return (1, BL);
    } else {
      if (defined(debug_mode) && debug_mode >= 1) {
	int idx_f = lookUpIndex(f);
	fprintf(out, "f_%s = %s is covered in the first sub-branch (<%s>, {%s}).", string(idx_f), f, branches[1][1], branches[1][2]);
	fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
      }
      return (checkEssentialInBranchRandom(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
    }
  }
}

proc equivalent(poly f, poly g) {
  // Basering is @RP.
  f = f / leadcoef(f);
  g = g / leadcoef(g);

  if (f == g) {
    return (1);
  } else {
    return (0);
  }
}

proc checkEssential(poly f, list M, list modcgs) {
  // Basering is @RP.
  list BL;
  int i, j;
  
  for (i = 1; i <= size(modcgs); i++) {
    if (appearsInBranch(f, modcgs[i])) {
      // f appears in this branch.
      poly pf;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (equivalent(f, modcgs[i][3][j][1] + modcgs[i][3][j][2])) {
	  pf = lppX(modcgs[i][3][j][1]);
	  break;
	}
      }
      int is_essential;
      list MRem = deletePolyFromList(M, f);
      ideal E_cur = modcgs[i][1];
      list N_cur = modcgs[i][2];
      list G_cur = modcgs[i][3];
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "Now come to Branch %s: (<%s>, {%s}):", string(i), E_cur, N_cur);
      }
      (is_essential, BL) = checkEssentialInBranch(f, pf, MRem, E_cur, N_cur, G_cur, BL);
      if (is_essential) {
	if (defined(debug_mode) && debug_mode == 1) {
	  fprintf(out, "%s is essential" + newline + "=================", string(f));
	}
	return (1, list());
      } 
    }
  }

  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "%s is non-essential" + newline + "=====================", string(f));
  }
  return (0, BL);
}

proc checkEssentialRandom(poly f, list M, list modcgs) {
  // Basering is @RP.
  list BL;
  int i, j;
  
  for (i = 1; i <= size(modcgs); i++) {
    if (appearsInBranch(f, modcgs[i])) {
      // f appears in this branch.
      poly pf;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (equivalent(f, modcgs[i][3][j][1] + modcgs[i][3][j][2])) {
	  pf = lppX(modcgs[i][3][j][1]);
	  break;
	}
      }
      int is_essential;
      list MRem = deletePolyFromList(M, f);
      ideal E_cur = modcgs[i][1];
      list N_cur = modcgs[i][2];
      list G_cur = modcgs[i][3];
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "Now come to Branch %s: (<%s>, {%s}):", string(i), E_cur, N_cur);
      }
      (is_essential, BL) = checkEssentialInBranchRandom(f, pf, MRem, E_cur, N_cur, G_cur, BL);
      if (is_essential) {
	if (defined(debug_mode) && debug_mode == 1) {
	  fprintf(out, "%s is essential" + newline + "=================", string(f));
	}
	return (1, list());
      } 
    }
  }

  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "%s is non-essential" + newline + "=====================", string(f));
  }
  return (0, BL);
}

proc listContains(list l, poly f) {
  if (size(l) == 0) {
    return (0);
  } 

  int i;
  for (i = 1; i <= size(l); i++) {
    if (l[i] == f) {
      return (1);
    }
  }

  return (0);
}

proc idealContains(ideal I, poly f) {
  if (size(I) == 0) {
    return (0);
  }

  int i;
  for (i = 1; i <= size(I); i++) {
    if (I[i] == f) {
      return (1);
    }
  }

  return (0);
}

proc listLookUp(list l, poly f) {
  if (size(l) == 0) {
    return (-1);
  }

  int i;
  for (i = 1; i <= size(l); i++) {
    if (l[i] == f || l[i] == -f) {
      return (i);
    }
  }

  return (-1);
}

proc idealLookUp(ideal I, poly f) {
  if (size(I) == 0) {
    return (-1);
  }

  int i;
  for (i = 1; i <= size(I); i++) {
    if (I[i] == f) {
      return (i);
    }
  }

  return (-1);
}


proc listContainsList(list m_l, list m) {
  if (size(m_l) == 0) {
    return (0);
  }

  int i;
  for (i = 1; i <= size(m_l); i++) {
    if (listEquals(m_l[i], m)) {
      return (1);
    }
  }

  return (0);
}

proc listEquals(list l1, list l2) {
  if (size(l1) != size(l2)) {
    return (0);
  }

  if (size(l1) == 0) {
    if (size(l2) == 0) {
      return (1);
    } else {return (0);}
  }

  if (size(l2) == 0) {
    return (0);
  }

  // General Case.
  int i;
  for (i = 1; i <= size(l1); i++) {
    if (!listContains(l2, l1[i])) {
      return (0);
    }
  }

  for (i = 1; i <= size(l2); i++) {
    if (!listContains(l1, l2[i])) {
      return (0);
    }
  }

  return (1);
}

proc idealEquals(ideal E1, ideal E2) {
  list L1 = idealToList(E1);
  list L2 = idealToList(E2);

  return (listEquals(L1, L2));
}

proc set_global_objects() {
  // Basering is @R.
  def BR = basering;

  list Variables;
  int i;
  for (i = 1; i <= nvars(BR); i++) {
    Variables[i] = var(i);
  }
  
  // Siwtch to @RP.
  setring @RP;
  def Variables = imap(BR, Variables);

  // Switch to @P.
  setring @P;
  list Parameters;
  for (i = 1; i <= nvars(@P); i++) {
    Parameters[i] = var(i);
  }

  // Switch back to @RP.
  setring @RP;
  def Parameters = imap(@P, Parameters);

  poly VMinDPoly = Variables[size(Variables)];
  list Checks = 0, 0, 0, 0, 0, 0;

  export(Variables, Parameters, VMinDPoly, Checks);

  // Switch back to @R.
  setring BR;
}

proc mcgbMain(ideal E, list N, ideal F) {
  // basering is @R.
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();

  set_global_objects();

  G = purifyCGB(G);

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);
  G = sortSetDesc(G);

  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;
  for (i = 1; i <= size(G); i++) {
    M[i] = G[i];
  }

  for (i = 1; i <= size(G); i++) {
    poly cur_f = G[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check f_%s = %s:", string(i), cur_f);
    }
    int is_essential;
    list BL;
    (is_essential, BL) = checkEssential(cur_f, M, modcgsRed);
    if (is_essential == 0) {
      
      list modcgs1;
      for (j = 1; j <= size(modcgsRed); j++) {
	if (!appearsInBranch(cur_f, modcgsRed[j])) {
	  modcgs1 = insert(modcgs1, modcgsRed[j], size(modcgs1));
	}
      }
      for (j = 1; j <= size(BL); j++) {
	modcgs1 = insert(modcgs1, BL[j], size(modcgs1));
      }
      modcgsRed = modcgs1;
      M = deletePolyFromList(M, cur_f);
    } 
    
  }


  // Switch back to @R.
  setring(@R);
  def M = imap(@RP, M);
  def modcgsRed = imap(@RP, modcgsRed);

  return (M, modcgsRed);
}

proc mcgbRandMain(ideal E, list N, ideal F) {
  // basering is @R.
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();
  set_global_objects();

  G = purifyCGB(G);

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);

  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;
  for (i = 1; i <= size(G); i++) {
    M[i] = G[i];
  }

  int size_cgb = size(G);
  list checked_indices;

  while (size(checked_indices) < size_cgb) {
    int cur_idx = random(1, size_cgb);
    while (listContains(checked_indices, cur_idx)) {
      cur_idx = random(1, size_cgb);
    }
    poly cur_f = G[cur_idx];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check f_%s = %s:", string(cur_idx), cur_f);
    }
    int is_essential;
    list BL;
    (is_essential, BL) = checkEssentialRandom(cur_f, M, modcgsRed);
    if (is_essential == 0) {
      
      list modcgs1;
      for (j = 1; j <= size(modcgsRed); j++) {
	if (!appearsInBranch(cur_f, modcgsRed[j])) {
	  modcgs1 = insert(modcgs1, modcgsRed[j], size(modcgs1));
	}
      }
      for (j = 1; j <= size(BL); j++) {
	modcgs1 = insert(modcgs1, BL[j], size(modcgs1));
      }
      modcgsRed = modcgs1;
      M = deletePolyFromList(M, cur_f);
    } 
    checked_indices = insert(checked_indices, cur_idx, size(checked_indices));
  }
  

  // Switch back to @R.
  setring(@R);
  def M = imap(@RP, M);
  def modcgsRed = imap(@RP, modcgsRed);

  return (M, modcgsRed);
}

proc homogenize_ring(string var_name) {
  // Basering is @R.
  def BR = basering;

  if (defined(@H)) {
    kill @H;
  }

  list ring_list = ringlist(BR);
  
  // Add the variable name.
  ring_list[2] = insert(ring_list[2], var_name, size(ring_list[2]));

  // Update the term ordering configuration.
  intvec iv = ring_list[3][1][2];
  iv = iv, 1;
  ring_list[3][1][2] = iv;

  // Construct the associated homogeneous ring.
  def @H = ring(ring_list);
  exportto(Top, @H);

  setring BR;
}

proc mcgbRandMainHomo(ideal E, list N, ideal F, string var_name) {
  def BR = basering;

  // Construct the homogeneous ring from @R.
  homogenize_ring(var_name);

  // Switch to @H.
  setring @H;
  def E = imap(BR, E);
  def N = imap(BR, N);
  def F = imap(BR, F);
  def additional_var = var(nvars(@H));

  // Homogenize F.
  F = homog(F, additional_var);

  // Construct rings @R = @H, @RP, @P.
  set_global_rings_mcgb();

  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();

  // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);

  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;
  for (i = 1; i <= size(G); i++) {
    M[i] = G[i];
  }

  int size_cgb = size(G);
  list checked_indices;

  while (size(checked_indices) < size_cgb) {
    int cur_idx = random(1, size_cgb);
    while (listContains(checked_indices, cur_idx)) {
      cur_idx = random(1, size_cgb);
    }
    poly cur_f = G[cur_idx];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check f_%s = %s:", string(cur_idx), cur_f);
    }
    int is_essential;
    list BL;
    (is_essential, BL) = checkEssential(cur_f, M, modcgsRed);
    if (is_essential == 0) {
      
      list modcgs1;
      for (j = 1; j <= size(modcgsRed); j++) {
	if (!appearsInBranch(cur_f, modcgsRed[j])) {
	  modcgs1 = insert(modcgs1, modcgsRed[j], size(modcgs1));
	}
      }
      for (j = 1; j <= size(BL); j++) {
	modcgs1 = insert(modcgs1, BL[j], size(modcgs1));
      }
      modcgsRed = modcgs1;
      M = deletePolyFromList(M, cur_f);
    } 
    checked_indices = insert(checked_indices, cur_idx, size(checked_indices));
  }
  

  // Switch back to @R.
  setring(@R);
  def M = imap(@RP, M);
  def modcgsRed = imap(@RP, modcgsRed);

  return (M, modcgsRed);
}

// For Canonical CGB.

proc monic(poly f) {
  
  if (f == 0) {
    return (f);
  } else {
    return (f / leadcoef(f));
  }
}

proc paramMonic(poly f) {
  if (f == 0) {
    return (f);
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    ring_flag = 1;
  }

  poly g = f / leadcoef(f);
  if(ring_flag) {
    setring BR;
    def g = imap(@RP, g);
  }

  return (g);
}

proc makeSetParamMonic(L) {
  if (typeof(L) != "ideal" && typeof(L) != "list") {
    ERROR("makeSetParamMonic: L must be either an ideal or a list!");
  }

  if (size(L) == 0) {
    return (L);
  }

  int i;
  for (i = 1; i <= size(L); i++) {
    L[i] = paramMonic(L[i]);
  }

  return (L);
}

proc makeSetMonic(L) {
  if (typeof(L) != "ideal" && typeof(L) != "list") {
    ERROR("makeSetMonic: L must be either an ideal or a list!");
  }

  int i;
  for (i = 1; i <= size(L); i++) {
    L[i] = monic(L[i]);
  }

  return (L);
}

proc lesscoef(poly coef_f, coef_g) {
  // basering is @RP.
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def coef_f = imap(BR, coef_f);
    def coef_g = imap(BR, coef_g);
    ring_flag = 1;
  }

  if (coef_f == 0 && coef_g == 0) {
    if (ring_flag) {
      setring BR;
    }
    return (2);
  }

  if (leadmonom(coef_f) < leadmonom(coef_g)) {
    if (ring_flag) {
      setring BR;
    }
    return (1);
  } else {
    if (leadmonom(coef_f) > leadmonom(coef_g)) {
      if (ring_flag) {
	setring BR;
      }
      return (0);
    } else {
      if (leadcoef(coef_f) == leadcoef(coef_g)) {
	int res = lesscoef(coef_f - lead(coef_f), coef_g - lead(coef_g));
	if (ring_flag) {
	  setring BR;
	}
	return (res);
      } else {
	int res = leadcoef(coef_f) < leadcoef(coef_g);
	if (ring_flag) {
	  setring BR;
	}
	return (res);
      }
    }
  }
}

proc lesspoly(poly f, poly g) 
"
f, g are monic polynomials.
"
{
  // basering is @RP.
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def g = imap(BR, g);
    ring_flag = 1;
  }

  if (f == 0 || g == 0) {
    if (ring_flag) {
      setring BR;
    }
    return (2);
  }

  if (lppX(f) < lppX(g)) {
    if (ring_flag) {
      setring BR;
    }
    return (1);
  } else {
    if (lppX(f) > lppX(g)) {
      if (ring_flag) {
	setring BR;
      }
      return (0);
    } else {
      poly lc_f = leadcoef_U(f);
      poly lc_g = leadcoef_U(g);
      if (lc_f != lc_g) {
	int res = lesscoef(lc_f, lc_g);
	if (ring_flag) {
	  setring BR;
	}
	return (res);
      } else {
	int res = lesspoly(f - lm_X(f), g - lm_X(g));
	if (ring_flag) {
	  setring BR;
	}
	return (res);
      }
    }
  }
}

proc lessSet(list M1, list M2) 
"
All polys in M1 and M2 are monic.
"
{
  // basering is @RP.
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def M1 = imap(BR, M1);
    def M2 = imap(BR, M2);
    ring_flag = 1;
  }

  if (size(M1) == 0) {
    if (size(M2) > 0) {
      if (ring_flag) {
	setring BR;
      }
      return (1);
    } else {
      if (ring_flag) {
	setring BR;
      }
      return (2);
    }
  }

  if (size(M2) == 0) {
    if (ring_flag) {
      setring BR;
    }
    return (0);
  }

  // General case.
  M1 = sortSetAsce(makeSetMonic(M1));
  M2 = sortSetAsce(makeSetMonic(M2));
  int cmp_res = lesspoly(M1[size(M1)], M2[size(M2)]);
  if (cmp_res != 2) {
    if (ring_flag) {
      setring BR;
    }
    return (cmp_res);
  } else {
    list M1_sub = delete(M1, size(M1));
    list M2_sub = delete(M2, size(M2));
    int res = lessSet(M1_sub, M2_sub);
    if (ring_flag) {
      setring BR;
    }
    return (res);
  }

}

proc sortSetDesc(I) {
  if (typeof(I) != "ideal" && typeof(I) != "list") {
    ERROR("sortSetDesc: I must be either an ideal or a list!");
  }

  if (size(I) <= 1) {
    return (I);
  }

  // Bubble sort.
  int i;
  int swapped = 1;
  int n = size(I);
  poly tmp;
  
  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n-1; i++) {
      if (lesspoly(I[i], I[i+1])) {
	tmp = I[i];
	I[i] = I[i+1];
	I[i+1] = tmp;
	swapped = 1;
      }
    }
    n = n - 1;
  }

  return (I);
}

proc sortSetAsce(L) {
  if (typeof(L) != "ideal" && typeof(L) != "list") {
    ERROR("sortSetAsce: L must be either an ideal or a list!");
  }

  int flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def L = imap(BR, L);
    flag = 1;
  }
  
  if (size(L) <= 1) {
    if (flag) {
      setring BR;
    }
    return (L);
  }

  // Bubble sort.
  int i;
  int swapped = 1;
  int n = size(L);
  poly tmp;
  
  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n-1; i++) {
      if (!lesspoly(L[i], L[i+1])) {
	tmp = L[i];
	L[i] = L[i+1];
	L[i+1] = tmp;
	swapped = 1;
      }
    }

    n = n - 1;
  }

  if (flag) {
    setring BR;
    def L_res = imap(@RP, L);
    return (L_res);
  } else {
    return (L);
  }
}

proc sortMCGBs(list MCGBs, list M_norms) {
  // Basering is @R.
  if (size(MCGBs) != size(M_norms)) {
    ERROR("sortMCGBs: sizes of MCGBs and M_norms must be equal!");
  }

  if (size(M_norms) <= 1) {
    return (MCGBs, M_norms);
  }
  
  def BR = basering;
  setring @RP;
  def MCGBs = imap(@R, MCGBs);
  def M_norms = imap(@R, M_norms);

  if (size(MCGBs) <= 1) {
    setring BR;
    return (MCGBs);
  }

  // Bubble sort.
  int i;
  int swapped = 1;
  int n = size(M_norms);
  list M_tmp;

  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n - 1; i++) {
      int cmp_res = lessSet(M_norms[i], M_norms[i+1]);
      if (cmp_res != 1) {
	if (!cmp_res) {
	  // M_norms[i] > M_norms[i+1].
	  (MCGBs[i], MCGBs[i+1]) = swapSets(MCGBs[i], MCGBs[i+1]);
	  (M_norms[i], M_norms[i+1]) = swapSets(M_norms[i], M_norms[i+1]);
	  swapped = 1;
	} else {
	  // M_norms[i] == M_norms[i+1].
	  if (!lessSet(MCGBs[i], MCGBs[i+1])) {
	    // MCGBs[i] > MCGBs[i+1].
	    (MCGBs[i], MCGBs[i+1]) = swapSets(MCGBs[i], MCGBs[i+1]);
	    (M_norms[i], M_norms[i+1]) = swapSets(M_norms[i], M_norms[i+1]);
	    swapped = 1;
	  }
	}
      }

    } // End for.

    n = n - 1;
  }

  setring BR;
  def MCGBs_res = imap(@RP, MCGBs);
  def M_norms_res = imap(@RP, M_norms);
  
  return (MCGBs_res, M_norms_res);
}

proc swapSets(L1, L2) {
  if (typeof(L1) != "ideal" && typeof(L1) != "list") {
    ERROR("swapSets: L1 must be either an ideal or a list!");
  }

  if (typeof(L2) != "ideal" && typeof(L2) != "list") {
    ERROR("swapSets: L2 must be either an ideal or a list!");
  }

  if (typeof(L1) != typeof(L2)) {
    ERROR("swapSets: L1 and L2 must have the same type!");
  }

  return (L2, L1);
}

proc idealExcludePoly(ideal M, poly f) {
  // Basering is @RP.
  if (size(M) == 0) {
    return (M);
  }

  ideal new_M;
  int i;

  for (i = 1; i <= size(M); i++) {
    if (!equivalent(M[i], f)) {
      new_M = new_M + M[i];
    }
  }

  return (new_M);
}

proc updateCGS(list CGS, poly f, list BL) {
  // Basering @RP.
  if (size(CGS) == 0) {return (CGS);}

  list CGS_new;
  int i;

  for (i = 1; i <= size(CGS); i++) {
    if (!appearsInBranch(f, CGS[i])) {
      CGS_new = insert(CGS_new, CGS[i], size(CGS_new));
    }
  }

  for (i = 1; i <= size(BL); i++) {
    CGS_new = insert(CGS_new, BL[i], size(CGS_new));
  }

  return (CGS_new);
}

proc listAsceOrd(list L) {
  if (size(L) <= 1) {return (L);}

  // Bubble sort.
  int i;
  int swapped = 1;
  int n = size(L);
  poly tmp;

  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n-1; i++) {
      if (lesspoly(L[i+1], L[i])) {
	tmp = L[i];
	L[i] = L[i+1];
	L[i+1] = tmp;
	swapped = 1;
      }
    }
    n = n - 1;
  }

  return (L);
}

/*
MCGB construction based on essentiality checking 
  and simplification w.r.t. K[X, U].
 */

proc getEssentialOnlyInBranchByHC(poly f, poly pp_f, list higher_coefs, poly g, list G_can, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  if (size(higher_coefs) == 0) {
    // g covers f in (E, N).
    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));

    return (BL);
  } else {
    int i;
    for (i = 1; i <= size(higher_coefs); i++) {
      poly cur_c = higher_coefs[i];

      if (checkNull(cur_c, E, N)) {
	// sigma(cur_c) is always 0.
	i++; // In SINGULAR, we need this statement before continue.
	continue;
      } else {
	if (checkNonNull(cur_c, E, N)) {
	  // sigma(cur_c) is never 0.
	  G_can = deletePolyFromList(G_can, g);
	  return (getEssentialOnlyInBranch(f, pp_f, G_can, E, N, G_branch, BL));
	} else {
	  // sigma(cur_c) is not determined.
	  list branches = splitBranch(E, N, cur_c);
	  list G_can_rem = deletePolyFromList(G_can_rem, g);
	  BL = getEssentialOnlyInBranch(f, pp_f, G_can, branches[1][1], branches[1][2], G_branch, BL);
	  BL = getEssentialOnlyInBranch(f, pp_f, G_can, branches[2][1], branches[2][2], G_branch, BL);
	  return (BL);
	}
      }
    } // End for.
    
    // all higher coefs are zero.
    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));

    return (BL);
  } // End if.
}

proc getEssentialOnlyInBranch(poly f, poly pp_f, list MRem, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  MRem = listAsceOrd(MRem);
  list G_can = getCandidatePolys(pp_f, MRem, E, N);
  
  if (size(G_can) == 0) {
    list branch = E, N, G_branch;
    BL = insert(BL, branch, size(BL));
    return (BL);
  }

  poly g = G_can[1];
  list higher_coefs = getHigherCoefs(g, pp_f);
  poly cp = getCoefOfPP(g, pp_f);
  if (checkNonNull(cp, E, N)) {
    return (getEssentialOnlyInBranchByHC(f, pp_f, higher_coefs, g, G_can, E, N, G_branch, BL));
  } else {
    list branches = splitBranch(E, N, cp);
    list G_can_rem = deletePolyFromList(G_can, g);
    BL = getEssentialOnlyInBranch(f, pp_f, G_can_rem, branches[1][1], branches[1][2], G_branch, BL);
    BL = getEssentialOnlyInBranch(f, pp_f, G_can, branches[2][1], branches[2][2], G_branch, BL);
    return (BL);
  }
}

proc getEssentialOnlyCGS(poly f, list M, list CGS) {
  // Basering is @RP.
  list BL;
  int i, j;

  for (i = 1; i <= size(CGS); i++) {
    if (appearsInBranch(f, CGS[i])) {
      poly pp_f;
      for (j = 1; j <= size(CGS[i][3]); j++) {
	if (equivalent(f, CGS[i][3][j][1] + CGS[i][3][j][2])) {
	  pp_f = lppX(CGS[i][3][j][1]);
	}
      }
      list MRem = deletePolyFromList(M, f);
      ideal E_cur = CGS[i][1];
      list N_cur = CGS[i][2];
      list G_cur = CGS[i][3];
      BL = getEssentialOnlyInBranch(f, pp_f, MRem, E_cur, N_cur, G_cur, BL);
      
    }
  }

  CGS = updateCGS(CGS, f, BL);
  
  for (i = 1; i <= size(CGS); i++) {
    if (appearsInBranch(f, CGS[i])) {
      return (1, CGS);
    }
  }

  return (0, CGS);
}

// A little bit cheating.
// Must be obsolete.
proc checkCGB(list M1, list M, list CGS) {
  // Basering is @RP.
  poly g;
  int i;
  int is_essential;
  list BL;

  for (i = 1; i <= size(M); i++) {
    if (!listContains(M1, M[i])) {
      g = M[i];
      break;
    }
  }

  if (g == 0) {return (0, list());}

  if (size(CGS) == 0) {return (1, CGS);}

  (is_essential, BL) = checkEssential(g, M1, CGS);

  if (is_essential) {
    return(0, list());
  } else {
    CGS = updateCGS(CGS, g, BL);
    return (1, CGS);
  }
}

proc trySubstitute(poly f, poly f_red, list M, list CGS) {
  // Basering is @RP.
  int is_essential;
  list CGS1;
  (is_essential, CGS1) = getEssentialOnlyCGS(f, M, CGS);

  if (!is_essential) {
    return (-1, CGS1);
  } else {
    int success;
    list M1 = substPolyInList(M, f, f_red);
    (success, CGS1) = checkCGB(M1, M, CGS1);
    if (success) {
      return (1, CGS1);
    } else {
      return (0, list());
    }
  }
}

proc substPolyInList(list M, poly g_old, poly g_new) {
  // Basering is @RP.
  int idx = listLookUp(M, g_old);

  if (idx != -1) {
    M = delete(M, idx);
    M = insert(M, g_new, idx - 1);
  }

  return (M);
}

proc ccgbMain(ideal E, list N, ideal F) {
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();
  set_global_objects();

  G = purifyCGB(G);

  // Switch to @RP.
  setring @RP;
  def G = imap(@R, G);
  G = sortSetDesc(G);
  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;

  for (i = 1; i <= size(G); i++) {
    M = insert(M, G[i], size(M));
  }

  for (i = 1; i <= size(G); i++) {
    poly cur_g = G[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check g_%s = %s:", string(i), cur_g);
    }
    int is_essential;
    list BL;
    list modcgs_new;
    
    ideal MRem_ideal;
    for (j = 1; j <= size(M); j++) {
      if (M[j] != cur_g) {
	MRem_ideal = MRem_ideal + M[j];
      }
    }

    poly g_red = reduce(cur_g, MRem_ideal);
    g_red = monic(g_red);
    if (g_red == 0 || g_red == cur_g) {
      (is_essential, BL) = checkEssential(cur_g, M, modcgsRed);
      if (!is_essential) {
	modcgsRed = updateCGS(modcgsRed, cur_g, BL);
	M = deletePolyFromList(M, cur_g);
      }
    } else {
      int success; 
      (success, modcgs_new) = trySubstitute(cur_g, g_red, M, modcgsRed);

      if (success == -1) {
	// cur_g is already non-essential.
	modcgsRed = modcgs_new;
	M = deletePolyFromList(M, cur_g);
      } else {
	if (success == 1) {
	  // cur_g is essential,
	  // and when replaced by g_red, M is still a CGB.
	  modcgsRed = modcgs_new;
	  M = substPolyInList(M, cur_g, g_red);
	}
	// Otherwise, cur_g is kept in M.
      }

    }
  } // End of for.

  ideal M_ideal;
  for (i = 1; i <= size(M); i++) {
    M_ideal = M_ideal + M[i];
  }

  // Switch back to @R.
  setring @R;
  def CCGB = imap(@RP, M_ideal);
  def CGSRed = imap(@RP, modcgsRed);
  
  return (CCGB, CGSRed);
}

proc getRGB(ideal F) {
  // Basering is @R.
  if (size(F) == 0) {return (ideal());}

  def BR = basering;
  setring @RP;
  def F = imap(BR, F);
  option(redSB);
  def RGB = std(F);
  if (size(RGB) == 1 && RGB[1] == 1) {
    setring BR;
    return (ideal(1));
  } else {
    // Make polys in RGB monic.
    int i;
    for (i = 1; i <= size(RGB); i++) {
      RGB[i] = RGB[i] / leadcoef(RGB[i]);
    }

    setring BR;
    def RGB = imap(@RP, RGB);
    return (RGB);
  }
}

/*
Print out results.
 */

proc showMCGB(list M, list global_polys, link out) {
  // Basering is @R.
  int i;

  fprintf(out, "M = [" + newline );
  if (size(M) == 0) {
    fprintf(out, newline);
  } else {
    int idx;
    for (i = 1; i < size(M); i++) {
      idx = listLookUp(global_polys, M[i]);
      if (idx == -1) {show(M[i]);ERROR("This polynomial is not numbered!");}
      fprintf(out, "/* f_%s = */ %s,", string(idx), M[i]);
    }
    if (idx == -1) {show(M[i]);ERROR("weird");}
    idx = listLookUp(global_polys, M[size(M)]);
    fprintf(out, "/* f_%s = */ %s;" + newline, string(idx), M[size(M)]);
  }
  fprintf(out, "]."+newline);
}

proc showCCGB(G, list global_polys, link out) {
  // G can only be an ideal or a list.
  if (typeof(G) != "ideal" && typeof(G) != "list") {
    ERROR("showCCGB: G is not an ideal or a list!");
  }

  G = sortSetAsce(G);

  int i;
  fprintf(out, "C = [" + newline);
  if (size(G) == 0) {
    fprintf(out, newline);
  } else {
    int idx;
    for (i = 1; i < size(G); i++) {
      idx = listLookUp(global_polys, G[i]);
      fprintf(out, "/* f_%s = */ %s,", string(idx), G[i]);
    }
    idx = listLookUp(global_polys, G[size(G)]);
    fprintf(out, "/* f_%s = */ %s;" + newline, string(idx), G[size(G)]);
  }
  fprintf(out, "]."+newline);
}

proc showRGB(ideal G, list global_polys, link out) {
  // basering is @R.
  G = sortSetAsce(G);
  
  int i;
  fprintf(out, "RGB = [" + newline);
  if (size(G) == 0) {
    fprintf(out, newline);
  } else {
    int idx;
    for (i = 1; i < size(G); i++) {
      idx = listLookUp(global_polys, G[i]);
      fprintf(out, "/* f_%s = */ %s,", string(idx), G[i]);
    }
    idx = listLookUp(global_polys, G[size(G)]);
    fprintf(out, "/* f_%s = */ %s;" + newline, string(idx), G[size(G)]);
  }
  fprintf(out, "]."+newline);
}

// Das Problem: doesn't work for some examples, spec. in checkNull.
proc simplifyPoly(poly g, ideal E, list N) {
  int ring_flag = 0;
  list N_simpl = N;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def g = imap(BR, g);
    def E = imap(BR, E);
    if (!defined(N_simpl)) {
      def N = imap(BR, N_simpl);
    }
    ring_flag = 1;
  }

  poly g_nonzero = 0;
  poly g_zero = 0;
  ideal GB = groebner(radical(E));
  //ideal E_rad = radical(E);

  while (g != 0) {
    poly lc_g = leadcoef_U(g);

    if (checkNull(lc_g, E, N)) {
      // lc_g is determined to be 0.
      g_zero = g_zero + lm_X(g);
    } else {
      if (checkNonNull(lc_g, E, N)) {
	// lc_g is determined to be non-zero.
	g_nonzero = g_nonzero + lm_X(g);
      } else {
	// lc_g is not determined.
	poly f = reduce(lm_X(g), GB);
	g_nonzero = g_nonzero + f;
	g_zero = g_zero + lm_X(g) - f;
      }
    }
    
    g = g - lm_X(g);
  }

  if (ring_flag) {
    setring BR;
    def g_nonzero = imap(@RP, g_nonzero);
    def g_zero = imap(@RP, g_zero);
  }
  
  return (g_nonzero, g_zero);
}

proc buildLCUFactors(list G_tuple) {
  // Basering is @RP.
  if (size(G_tuple) == 0) {
    return (ideal());
  }

  poly lc_prod = 1;
  int i;
  for (i = 1; i <= size(G_tuple); i++) {
    if (G_tuple[i][1] != 0) {
      lc_prod = lc_prod * leadcoef_U(G_tuple[i][1]);
    }
  }

  ideal LC_factors = factorize(lc_prod, 1);
  return (LC_factors);
}

proc updateNonNullList(list N, ideal I) {
  // Basering is @RP.
  if (size(I) == 0) {
    return (N);
  }

  poly N_prod = 1;
  int i;
  if (size(N) != 0) {
    for (i = 1; i <= size(N); i++) {
      N_prod = N_prod * N[i];
    }
  }

  if (size(I) > 0) {
    for (i = 1; i <= size(I); i++) {
      N_prod = N_prod * I[i];
    }
  }

  ideal N_new_factors = factorize(N_prod, 1);
  list N_new;
  if (size(N_new_factors) == 0) {
    N_new = list(1);
  } else {
    for (i = 1; i <= size(N_new_factors); i++) {
      N_new = insert(N_new, N_new_factors[i], size(N_new));
    }
  }

  return (N_new);

}

/*
Minimal Dickson Basis construction.
 */

proc removeRedundancy(list G_tuple) {
  // Basering is @RP.
  if (size(G_tuple) == 0) {
    return (list());
  }

  int i;
  list G_tuple_new;
  for (i = 1; i <= size(G_tuple); i++) {
    if (G_tuple[i][1] != 0) {
      G_tuple_new = insert(G_tuple_new, G_tuple[i], size(G_tuple_new));
    }
  }

  return (G_tuple_new);
}

proc sortPolyAsce(list G_tuple) {
  // Basering is @RP.
  if (size(G_tuple) <= 1) {
    return (G_tuple);
  }

  // Bubble sort.
  int i;
  int swapped = 1;
  int n = size(G_tuple);
  list tmp;

  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n - 1; i++) {
      if (!lesspoly(G_tuple[i][1], G_tuple[i+1][1])) {
	tmp = G_tuple[i];
	G_tuple[i] = G_tuple[i+1];
	G_tuple[i+1] = tmp;
	swapped = 1;
      }
    }
    n = n - 1;
  }

  return (G_tuple);
}

proc removeLPPXRedundancy(list G_tuple) {
  // Basering is @RP.
  // G is sorted in an ascending order.

  if (size(G_tuple) <= 1) {
    return (G_tuple);
  }

  int i, j;
  for (i = 1; i <= size(G_tuple); i++) {
    for (j = i+1; j <= size(G_tuple); j++) {
      if (lppX(G_tuple[j][1]) / lppX(G_tuple[i][1]) != 0) {
	G_tuple = delete(G_tuple, j);
	continue;
      }
    }
  }

  return (G_tuple);
}

proc getMDBasis(list G_tuple) {
  // Basering is @RP.
  G_tuple = sortPolyAsce(G_tuple);
  G_tuple = removeLPPXRedundancy(G_tuple);

  return (G_tuple);
}

/*
Build CGS from a CGB.
 */

proc buildCGS_rec(ideal E, list N, list G_tuple, list CGS) {
  // Basering is @RP.
  if (size(G_tuple) == 0) {return (CGS);}

  if (!Check_Consistence_CGB(E, N)) {
    return (CGS);
  }

  // Simplify G_tuple due to E.
  int i;
  for (i = 1; i <= size(G_tuple); i++) {
    if (G_tuple[i][1] != 0) {
      poly g = G_tuple[i][1];
      poly g_nonzero, g_zero;
      (g_nonzero, g_zero) = simplifyPoly(g, E, N);
      G_tuple[i][1] = g_nonzero;
      G_tuple[i][2] = G_tuple[i][2] + g_zero;
    }
  }
  G_tuple = removeRedundancy(G_tuple);

  list mdbasis = getMDBasis(G_tuple);

  ideal LC_factors = buildLCUFactors(mdbasis);

  list N_branch = updateNonNullList(N, LC_factors);

  // Add new branch if consistent.
  if (Check_Consistence_CGB(E, N_branch)) {
    CGS = insert(CGS, list(E, N_branch, mdbasis), size(CGS));
  }
  
  list N_lc = N;
  for (i = 1; i <= size(LC_factors); i++) {
    poly lc_factor = LC_factors[i];
    CGS = buildCGS_rec(E+ideal(lc_factor), N_lc, G_tuple, CGS);
    N_lc = insert(N_lc, lc_factor, size(N_lc));
  }
  
  return (CGS);
}

proc buildCGS(list MCGB) {
  // Basering is @R.
  if (size(MCGB) == 0) {
    return (list());
  }

  // Switch to @RP.
  setring @RP;
  if (defined(MCGB)) {kill MCGB;}
  def MCGB = imap(@R, MCGB);
  if (defined(CGS)) {kill CGS;}
  list CGS;

  int i;
  list MCGB_tuple;
  for (i = 1; i<= size(MCGB); i++) {
    MCGB_tuple = insert(MCGB_tuple, list(MCGB[i], 0), size(MCGB_tuple));
  }

  CGS = buildCGS_rec(ideal(), list(1), MCGB_tuple, CGS);

  // Switch back to @R.
  setring @R;
  if (defined(CGS)) {kill CGS;}
  def CGS = imap(@RP, CGS);
  return (CGS);
}

/*
A sole function.
 */

proc makeCGBReduced(list M, list Modcgs) {
  // basering is @R.
  if (size(M) <= 1) {
    return (M);
  }

  // Switch to @RP.
  def BR = basering;
  setring @RP;
  def M = imap(BR, M);
  M = sortSetDesc(M);
  def Modcgs = imap(BR, Modcgs);

  list M_res = M;
  int i, j;

  for (i = 1; i <= size(M); i++) {
    poly cur_g = M[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check g_%s = %s:", string(i), cur_g);
    }

    int is_essential;
    list BL;
    list modcgs_new;

    ideal MRem_ideal;
    for (j = 1; j <= size(M_res); j++) {
      if (M_res[j] != cur_g) {
	MRem_ideal = MRem_ideal + M_res[j];
      }
    }

    poly g_red = reduce(cur_g, MRem_ideal);
    g_red = monic(g_red);

    if (g_red == 0 || g_red == cur_g) {
      (is_essential, BL) = checkEssential(cur_g, M_res, Modcgs);
      if (!is_essential) {
	Modcgs = updateCGS(Modcgs, cur_g, BL);
	M_res = deletePolyFromList(M_res, cur_g);
      }
    } else {
      int success;
      (success, modcgs_new) = trySubstitute(cur_g, g_red, M_res, Modcgs);

      if (success == -1) {
	// cur_g is already non-essential.
	Modcgs = modcgs_new;
	M_res = deletePolyFromList(M_res, cur_g);
      } else {
	if (success == 1) {
	  // cur_g is essential,
	  // and when replaced by g_red, M is still a CGB.
	  Modcgs = modcgs_new;
	  M_res = substPolyInList(M_res, cur_g, g_red);
	}
	// Otherwise, cur_g is kept in M_res.
      }
    }
  } // End for.

  // Switch back to basering.
  setring BR;
  def M_res = imap(@RP, M_res);
  
  return (M_res);
}

/*
Obsolete: Splitting operation on MCGBs.
 */

proc getSplitPolys(poly f, ideal RGB) {
  // Basering is @R.
  int flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def f = imap(BR, f);
    def RGB = imap(BR, RGB);
    flag = 1;
  }

  list quos;
  poly rem;
  (quos, rem) = traceReduction(f, RGB);
  int i;
  list L_poly, L_quo;

  for (i = 1; i <= size(quos); i++) {
    if (quos[i] != 0) {
      L_poly = insert(L_poly, RGB[i], size(L_poly));
      L_quo = insert(L_quo, quos[i], size(L_quo));
    }
  }

  if (size(L_poly) == 1 && L_quo[1] == 1) {
    L_poly = list();
    L_quo = list();
  }

  if (flag) {
    setring BR;
    def L_poly = imap(@RP, L_poly);
    def L_quo = imap(@RP, L_quo);
  }

  return (L_poly, L_quo);
}

proc splitCriterion(poly f, list L_poly, ideal I) {
  if (nameof(basering) != "@RP") {
    ERROR("splitCriterion: The operation must be performed in Ring @RP!");
  }

  if (size(L_poly) > 0) {
    ideal I_rad = radical(I);
    if (I_rad[1] == 1) {
      return (1);
    } else {
      // Problematic
      if (simplifyPoly(f, I_rad, list(1)) == 0) {
	return (1);
      }
    }

  }

  return (0);
}

proc splitCGB(list M, ideal RGB, proc func) {
  // Basering is @R.
  if (size(M) == 0) {
    return (M);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def M = imap(BR, M);
    def RGB = imap(BR, RGB);
    ring_flag = 1;
  }

  M = sortSetDesc(M);
  RGB = sortSetAsce(RGB);

  int cnt, i;
  int flag;
  list L_poly, L_quo;
  ideal I;
  
  cnt = 1;
  while (cnt <= size(M)) {
    flag = 0;
    (L_poly, L_quo) = getSplitPolys(M[cnt], RGB);
    I = getCriticalIdeal(M[cnt], RGB);

    if (size(L_poly) > 0 && func(M[cnt], L_poly, I)) {
      M = delete(M, cnt);
      for (i = 1; i <= size(L_poly); i++) {
	if (!listContains(M, L_poly[i])) {
	  M = insert(M, L_poly[i], size(M));
	}
      }
      flag = 1;
    }
    
    if (!flag) {
      cnt = cnt + 1;
    }

  }
  M = sortSetAsce(M);

  if (ring_flag) {
    setring BR;
    def M_res = imap(@RP, M);
    return (M_res);
  } else {
    return (M);
  }

}

/*
  mcgbGenerate algorithm:
Compute an MCGB directly from the given parametric ideal I.
 */

proc generalSimplRec(poly f, ideal G, ideal E, list N, list rem_list) {
  // basering is @RP.
  
  if (!Check_Consistence_CGB(E, N)) {
    return (rem_list);
  }

  poly f_nz, f_z;
  (f_nz, f_z) = simplifyPoly(f, E, N);

  if (f_nz == 0) {
    return (rem_list);
  }

  list N_comp = insert(N, leadcoef_U(f_nz), size(N));
  ideal G_nz = simplifyBasis(G, E, N_comp);

  poly rem, m;
  ideal quots;
  int i;

  list pd_struct = faithfulPDivi(f, f_nz, G, G_nz, E, N_comp);
  rem = pd_struct[1];
  quots = pd_struct[2];
  m = pd_struct[3];
  
  /*
  list pd_struct = pseudoDivi(f_nz, G_nz);
  rem = pd_struct[1];
  quots = pd_struct[2];
  m = pd_struct[3];
  */
  
  N_comp = insert(N_comp, m ,size(N_comp));
  fprintf(special_out, "E = <%s>,", E);
  fprintf(special_out, "N = {%s}.", N_comp);

  string pdivi_res;
  pdivi_res = "(" + string(m) + ") * (" + showParamPoly(f_nz) + ") = ";

  if (size(quots) == 1) {
    if (quots[1] != 0) {
      pdivi_res = pdivi_res + "(" + showParamPoly(quots[1]) + ")" + "G[1]";
    } else {
      pdivi_res = pdivi_res + "0";
    }
  } else {
    for (i = 1; i <= size(quots); i++) {
      if (quots[i] != 0) {
	pdivi_res = pdivi_res + "(" + showParamPoly(quots[i]) + ")" + "G[" + string(i) + "]) + ";
      }
    }
  } 

  pdivi_res = pdivi_res + " + " + showParamPoly(rem) + ".";
  
  if (rem != 0) {
    rem_list = insert(rem_list, rem, size(rem_list));
  }

  
  ideal N_comp_factors = getFactorIdeal(N_comp);

  poly factor_used = 1;
  for (i = 1; i <= size(N_comp_factors); i++) {
    ideal E_next = paramIdealInsert(E, N_comp_factors[i]);
    list N_next = insert(N, factor_used, size(N));
    factor_used = factor_used * N_comp_factors[i];
    rem_list = generalSimplRec(f, G, E_next, N_next, rem_list);
  }
  

  return (rem_list);
}

proc generalSimplify(poly f, ideal G, ideal E, list N) {
  // must work with both @R and @RP.
  if (size(G) == 0) {
    return (list(f));
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    if (!defined(f)) {
      def f = imap(BR, f);
    }
    def G = imap(BR, G);
    def E = imap(BR, E);
    if (!defined(N)) {
      def N = imap(BR, N);
    }
    ring_flag = 1;
  }

  list p_list = generalSimplRec(f, G, E, N, list());

  if (size(p_list) == 0) {
    if (ring_flag) {
      setring BR;
    }
    printf("%s is reduced to 0.", showParamPoly(f));
    return (list());
  } else {
    if (ring_flag) {
      setring BR;
      def p_list = imap(@RP, p_list);
    }
    printf("%s is simplified as:", showParamPoly(f));
    int i;
    printf("  {");
    for (i = 1; i <= size(p_list); i++) {
      printf("    %s,", showParamPoly(p_list[i]));
    }
    printf("  }.");
    printf("----------------------------");
    return (p_list);
  }
  
}

proc deletePolyFromIdeal(ideal I, poly f) {
  if (size(I) == 0) {
    return (I);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def I = imap(BR, I);
    if (!defined(f)) {
      def f = imap(BR, f);
    }
    ring_flag = 1;
  }

  ideal J;
  int i;
  for (i = 1; i <= size(I); i++) {
    if (I[i] != f) {
      J = J + I[i];
    }
  }

  if (ring_flag) {
    setring BR;
    def J = imap(@RP, J);
  }

  return (J);
}

proc simplifyBasis(ideal G, ideal E, list N) {
  if (size(G) == 0) {
    return (G);
  }

  list L;
  int i;
  poly f_nonzero, f_zero;
  for (i = 1; i <= size(G); i++) {
    (f_nonzero, f_zero) = simplifyPoly(G[i], E, N);
    L = insert(L, f_nonzero, size(L));
  }

  return (listToIdeal(L));
}

// Das Problem: m * f_nz != sum(G_nz, quots) + rem machmals.
proc faithfulPDivi(poly f_faith, poly f_nz, ideal G_faith, ideal G_nz, ideal E, list N) {
  list pd_struct_nz = pseudoDivi(f_nz, G_nz);
  poly rem, m;
  ideal quots;

  rem = pd_struct_nz[1];
  quots = pd_struct_nz[2];
  m = pd_struct_nz[3];
  N = insert(N, m, size(N));
  
  fprintf(special_out, "Unfaithful PDIVI:");
  string pdivi_res;
  pdivi_res = pdivi_res + showParamPoly(m) + " (" + showParamPoly(f_nz) + ") = ";
  
  int i;
  poly tmp_res = 0;
  for (i = 1; i<= size(quots); i++) {
    if (quots[i] != 0) {
      tmp_res = tmp_res + quots[i] * G_nz[i];
    }
  }
  
  for (i = 1; i <= size(quots); i++) {
    if (quots[i] != 0) {
      pdivi_res = pdivi_res + "(" + showParamPoly(quots[i]) + ")G[" + string(i) + "] +";
    }
  }
  pdivi_res = pdivi_res + showParamPoly(rem) + ".";

  fprintf(special_out, pdivi_res + newline);

  if (checkRemNull(rem, E, N)) {
    fprintf(special_out, "UNFAITHFUL REMAINDER equiv 0: %s.", showParamPoly(rem));
    return (list(0, quots, m));
  } else {
    fprintf(special_out, "UNFAITHFUL REMAINDER not 0: %s.", showParamPoly(rem));
    int i;
    poly res = 0;
    for (i = 1; i <= size(quots); i++) {
      if (quots[i] != 0) {
	res = res + quots[i] * G_faith[i];
      }
    }
    poly rem_faithful = m * f_faith - res;

    fprintf(special_out, "It's faithful version: %s.", showParamPoly(rem_faithful));
    
    return (list(rem_faithful, quots, m));
  }
  
}

proc deleteTuples(list pairs, poly f) {
  if (size(pairs) == 0) {
    return (pairs);
  }

  int cnt = 1;
  while (cnt <= size(pairs)) {
    if (pairs[cnt][1] == f || pairs[cnt][2] == f) {
      pairs = delete(pairs, cnt);
    } else {
      cnt = cnt + 1;
    }
  }

  return (pairs);
}

proc insertTuplesSorted(list pairs, list tuples) {
  // Assume pairs is sorted.
  if (size(tuples) == 0) {
    return (pairs);
  }

  tuples = sortPairs(tuples);

  if (size(pairs) == 0) {
    return (tuples);
  }

  int i;
  int pos = 1;
  for (i = 1; i <= size(tuples); i++) {
    while (lesspair(pairs[pos], tuples[i])) {
      pos = pos + 1;
      if (pos > size(pairs)) {
	break;
      }
    }
    if (pos > size(pairs)) {
      pairs = insert(pairs, tuples[i], size(pairs));
      pos = size(pairs);
    } else {
      pairs = insert(pairs, tuples[i], pos - 1);
      pos = pos + 1;
    }
  }

  return (pairs);
}

proc insertTuples(list pairs, ideal G, poly f) {
  
  if (size(G) == 0) {
    return (pairs);
  }
  
  int i;
  list pair_new_l;
  for (i = 1; i <= size(G); i++) {
    pair_new_l = insert(pair_new_l, ideal(G[i], f), size(pair_new_l));
  }

  pairs = insertTuplesSorted(pairs, pair_new_l);

  return (pairs);
}

proc getFaithfulSPoly(poly f, poly g, poly f_nz, poly g_nz) {
  if (f_nz == 0) {
    return (g, g_nz);
  }

  if (g_nz == 0) {
    return (f, f_nz);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    if (!defined(f)) {
      def f = imap(BR, f);
    }
    if (!defined(g)) {
      def g = imap(BR, g);
    }
    if (!defined(f_nz)) {
      def f_nz = imap(BR, f_nz);
    }
    if (!defined(g_nz)) {
      def g_nz = imap(BR, g_nz);
    }
    ring_flag = 1;
  }

  poly teller = lcm(lm_X(f_nz), lm_X(g_nz));
  poly h = (teller / lm_X(f_nz)) * f_nz - (teller / lm_X(g_nz)) * g_nz;
  poly h_faith = (teller / lm_X(f_nz)) * f - (teller / lm_X(g_nz)) * g;

  return (h_faith, h);
}

proc insertPolyToIdeal(ideal I, poly f) {
  if (size(I) == 0) {
    return (ideal(f));
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def I = imap(BR, I);
    if (!defined(f)) {
      def f = imap(BR, f);
    }
    ring_flag = 1;
  }

  ideal J = I + f;

  if (ring_flag) {
    setring BR;
    def J = imap(@RP, J);
  }

  return (J);
  
}

proc factorMultNonnull(list N, poly f) {
  if (size(N) == 0) {
    N = insert(N, f, size(N));
    return (N);
  }

  int i;
  for (i = 1; i <= size(N); i++) {
    N[i] = N[i] * f;
  }

  return (N);
}

proc mergeIdeal(ideal I, ideal J) {
  if (size(I) == 0) {
    return (J);
  }

  if (size(J) == 0) {
    return (I);
  }

  list L = idealToList(I);
  int i;
  for (i = 1; i <= size(J); i++) {
    L = insert(L, J[i], size(L));
  }

  return (listToIdeal(L));
}

proc extendBranchSpec(poly f, poly g, ideal E, list N) {
  // basering is @RP.
  
  int terminate_flag = 0;

  int end_f_flag = 0;
  int end_g_flag = 0;

  ideal E_tmp;
  poly m = 1;
  poly g_tmp = g;
  
  while (!end_f_flag) {
    if (leadmonom(leadcoef_U(f)) == 1 || f == 0) {
      end_f_flag = 1;
    }
    
    end_g_flag = 0;
    while (!end_g_flag) {
      if (leadmonom(leadcoef_U(g_tmp)) == 1 || g_tmp == 0) {
	end_g_flag = 1;
      }
      
      if (coprimeLPP(f, g_tmp)) {
	E_tmp = insertPolyToIdeal(E_tmp, leadcoef_U(g_tmp));
	g_tmp = g_tmp - lm_X(g_tmp);
      } else {
	m = m * leadcoef_U(g_tmp) * leadcoef_U(f);
	terminate_flag = 1;
	break;
      }
    }
    if (terminate_flag) {
      break;
    }
    E_tmp = ideal(leadcoef_U(f));
    f = f - lm_X(f);
    g_tmp = g;
  }
  
  if (!terminate_flag) {
    return (1, ideal(), list());
  }

    E = mergeIdeal(E, E_tmp);
  N = insert(N, m, size(N));

  return (0, E, N);
}

proc getLargestUnmarkedPolyIdx(list mp_list) {
  // basering is @RP.
  if (size(mp_list) == 0) {
    return (-1);
  }

  if (size(mp_list) == 1) {
    if (mp_list[1][2] == 0) {
      return (1);
    } else {
      return (-1);
    }
  }

  int i;
  int idx = -1;
  poly f;

  for (i = 1; i <= size(mp_list); i++) {
    if (idx == -1 && mp_list[i][2] == 0) {
      idx = i;
      f = mp_list[i][1];
    }
    
    if (idx != -1 && mp_list[i][1] > f && mp_list[i][2] == 0) {
      idx = i;
      f = mp_list[i][1];
    }
  }

  return (idx);
}

proc buildIdealFromMarkList(list mp_list) {
  // basering is @RP.
  if (size(mp_list) == 0) {
    return (ideal());
  }

  int i;
  ideal I;
  for (i = 1; i <= size(mp_list); i++) {
    I = insertPolyToIdeal(I, mp_list[i][1]);
  }

  return (I);
}

proc allMarked(list mp_list) {
  // basering is @RP.

  if (size(mp_list) == 0) {
    return (1);
  }

  int i;
  for (i = 1; i <= size(mp_list); i++) {
    if (mp_list[i][2] == 0) {
      return (0);
    }
  }

  return (1);
}

proc makeMarkList(ideal G) {
  // basering is @RP.
  if (size(G) == 0) {
    return (list());
  }

  int i;
  list mp_list;
  for (i = 1; i <= size(G); i++) {
    mp_list = insert(mp_list, list(G[i], 0), size(mp_list));
  }

  return (mp_list);
}

proc insertPolyWithGenSimpl(ideal G, poly rem, ideal E, list N) {
  // basering is @RP.
  if (rem == 0) {
    return (G);
  }

  G = insertPolyToIdeal(G, rem);
  G = sortSetDesc(G);
  list mp_list = makeMarkList(G);
  int j;
  ideal G = buildIdealFromMarkList(mp_list);

  while (!allMarked(mp_list)) {
    int idx = getLargestUnmarkedPolyIdx(mp_list);
    poly f = mp_list[idx][1];
    mp_list = delete(mp_list, idx);
    ideal I = deletePolyFromIdeal(G, f);
    list p_list = generalSimplify(f, I, E, N);
    if (size(p_list) == 0) {
      G = I;
    } else {
      for (j = 1; j <= size(p_list); j++) {
	if (p_list[j] != f) {
	  mp_list = insert(mp_list, list(p_list[j], 0), size(mp_list));
	  I = insertPolyToIdeal(I, p_list[j]);
	} else {
	  mp_list = insert(mp_list, list(p_list[j], 1), size(mp_list));
	  I = insertPolyToIdeal(I, p_list[j]);
	}
      }
      G = I;
    }
  }

  return (G);
}

proc generalSimplRecRaw(poly f, ideal G, ideal E, list N) {
  // basering is @RP.
  if (!Check_Consistence_CGB(E, N)) {
    return (0);
  }

  poly f_nz, f_z;
  (f_nz, f_z) = simplifyPoly(f, E, N);

  if (f_nz == 0) {
    return (0);
  }

  list N_comp = insert(N, leadcoef_U(f_nz), size(N));
  ideal G_nz = simplifyBasis(G, E, N_comp);

  poly rem, m;
  ideal quots;
  int i;

  list pd_struct = pseudoDivi(f_nz, G_nz);
  rem = pd_struct[1];
  quots = pd_struct[2];
  m = pd_struct[3];

  N_comp = insert(N_comp, m ,size(N_comp));

  string pdivi_res;
  pdivi_res = "(" + string(m) + ")" + "h = ";

  if (size(quots) == 1) {
    if (quots[1] != 0) {
      pdivi_res = pdivi_res + "(" + showParamPoly(quots[1]) + ")" + "G[1]";
    } else {
      pdivi_res = pdivi_res + "0";
    }
  } else {
    for (i = 1; i <= size(quots); i++) {
      if (quots[i] != 0) {
	pdivi_res = pdivi_res + "(" + showParamPoly(quots[i]) + ")" + "G[" + string(i) + "]) + ";
      }
    }
  } 

  pdivi_res = pdivi_res + " + " + showParamPoly(rem) + ".";
  
  if (rem != 0) {
    if (!checkRemNull(rem, E, N_comp)) {
      return (f);
    }
  }

  
  ideal N_comp_factors = getFactorIdeal(N_comp);

  poly factor_used = 1;
  for (i = 1; i <= size(N_comp_factors); i++) {
    ideal E_next = paramIdealInsert(E, N_comp_factors[i]);
    list N_next = insert(N, factor_used, size(N));
    factor_used = factor_used * N_comp_factors[i];
    if (generalSimplRecRaw(f, G, E_next, N_next) != 0) {
      return (f);
    }
  }
  

  return (0);
}

proc generalSimplifyRaw(poly f, ideal G, ideal E, list N) {
  // must work with both @R and @RP.
  if (size(G) == 0) {
    return (f);
  }
  
  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    if (!defined(f)) {
      def f = imap(BR, f);
    }
    def G = imap(BR, G);
    def E = imap(BR, E);
    if (!defined(N)) {
      def N = imap(BR, N);
    }
    ring_flag = 1;
  }

  poly p = generalSimplRecRaw(f, G, E, N);

  if (ring_flag) {
    setring BR;
    if (!defined(p)) {
      def p = imap(@RP, p);
    }
  }

  return (p);
}


proc mcgbGenRec(ideal G, list pairs, ideal cur_pair, ideal E, list N, ideal E_given, list N_given, int simpl_flag) {
  // basering is @RP.
  if (!Check_Consistence_CGB(E, N)) {
    return (G, pairs, simpl_flag);
  }

  // Take the smallest pair.
  poly f = cur_pair[1];
  poly g = cur_pair[2];

  poly f_nz, f_z;
  poly g_nz, g_z;
  (f_nz, f_z) = simplifyPoly(f, E, N);
  (g_nz, g_z) = simplifyPoly(g, E, N);

  int i;
  int computation_flag = 1;
  int split_flag = 1;
  poly rem, m;
  ideal quots;

  ideal E_new;
  list N_new;
  int opt_flag;
  (opt_flag, E_new, N_new) = optBuchberger(f_nz, g_nz, E, N);
  if (opt_flag == 1) {
    return (G, pairs, simpl_flag);
  } else {
    if (opt_flag == 2) {
      computation_flag = 0;
      split_flag = 0;
      rem = 0;
      E = E_new;
      N = N_new;
    }
  }

  list N_comp = N;

  if (split_flag) {
    if (f_nz != 0) {
      N_comp = insert(N_comp, leadcoef_U(f_nz), size(N_comp));
    }

    if (g_nz != 0) {
      N_comp = insert(N_comp, leadcoef_U(g_nz), size(N_comp));
    }
  }

  if (computation_flag) {
    poly h_faith, h;
    (h_faith, h) = getFaithfulSPoly(f, g, f_nz, g_nz);
    ideal G_nz = simplifyBasis(G, E, N_comp);
    
    fprintf(special_out, "(G) = [");
    for (i = 1; i <= size(G_nz); i++) {
      fprintf(special_out, "%s,", showParamPoly(G_nz[i]));
    }
    fprintf(special_out, "].");

    list pd_struct = faithfulPDivi(h_faith, h, G, G_nz, E, N_comp);
    rem = pd_struct[1];
    quots = pd_struct[2];
    m = pd_struct[3];

    string pdivi_res;
    pdivi_res = "(" + string(m) + ")" + "h = ";

    if (size(quots) == 1) {
      if (quots[1] != 0) {
	pdivi_res = pdivi_res + "(" + showParamPoly(quots[1]) + ")" + "G[1]";
      } else {
	pdivi_res = pdivi_res + "0";
      }
    } else {
      for (i = 1; i <= size(quots); i++) {
	if (quots[i] != 0) {
	  pdivi_res = pdivi_res + "(" + showParamPoly(quots[i]) + ")" + "G[" + string(i) + "]) + ";
	}
      }
    } 

    pdivi_res = pdivi_res + " + " + showParamPoly(rem) + ".";

    fprintf(special_out, "%s", pdivi_res);

    N_comp = insert(N_comp, m, size(N_comp));
  }

  fprintf(special_out, "E = <%s>,", E);
  fprintf(special_out, "N = {%s}.", N_comp);
  
  if (rem != 0) {
    // Add new polynomial if possible.
    G = insertPolyWithGenSimpl(G, rem, E_given, N_given);
    simpl_flag = 0;
  }


  if (split_flag) {
    ideal N_comp_factors = getFactorIdeal(N_comp);
  
    poly factor_used = 1;
    for (i = 1; i <= size(N_comp_factors); i++) {
      ideal E_next = paramIdealInsert(E, N_comp_factors[i]);
      list N_next = insert(N, factor_used, size(N));
      int local_simpl_flag = 1;
      factor_used = factor_used * N_comp_factors[i];
      (G, pairs, local_simpl_flag) = mcgbGenRec(G, pairs, cur_pair, E_next, N_next, E_given, N_given, local_simpl_flag);
      if (local_simpl_flag == 0) {
	simpl_flag = 0;
      }
    }
    return (G, pairs, simpl_flag);
  } else {
  
    (G, pairs, simpl_flag) = mcgbGenRec(G, pairs, cur_pair, E, N_comp, E_given, N_given, simpl_flag);
    return (G, pairs, simpl_flag);
  }
  
}

proc deletePair(list pairs, ideal tuple) {
  if (size(pairs) == 0) {
    return (pairs);
  }

  tuple = makePairWell(tuple);
  
  int i;
  for (i = 1; i <= size(pairs); i++) {
    if (pairs[i][1] == tuple[1] && pairs[i][2] == tuple[2]) {
      pairs = delete(pairs, i);
      break;
    }
  }

  return (pairs);
}

proc makePairWell(ideal pair) {
  if (lesspoly(pair[1], pair[2])) {
    return (pair);
  } else {
    ideal pair_new = pair[2], pair[1];
    return (pair_new);
  }
}

proc lesspair(ideal P1, ideal P2) {
  P1 = makePairWell(P1);
  P2 = makePairWell(P2);

  int cmp_l = lesspoly(P1[1], P2[1]);
  if (cmp_l == 2) {
    // P1[1] == P2[1].
    int cmp_r = lesspoly(P1[2], P2[2]);
    if (cmp_r > 0) {
      // P1[2] <= P2[2].
      return (1);
    } else {
      return (0);
    }
  } else {
    if (cmp_l == 1) {
      // P1[1] < P2[1].
      return (1);
    } else {
      // P1[1] > P2[1].
      return (0);
    }
  }
}

proc sortPairs(list pairs) {
  if (size(pairs) == 0) {
    return (pairs);
  }

  int i;
  for (i = 1; i <= size(pairs); i++) {
    pairs[i] = makePairWell(pairs[i]);
  }

  if (size(pairs) == 1) {
    return (pairs);
  }
  
  // Bubble sort.
  int swapped = 1;
  int n = size(pairs);
  ideal tmp;

  while (swapped == 1) {
    swapped = 0;
    for (i = 1; i <= n - 1; i++) {
      if (!lesspair(pairs[i], pairs[i+1])) {
	tmp = pairs[i];
	pairs[i] = pairs[i+1];
	pairs[i+1] = tmp;
	swapped = 1;
      }
    }

    n = n - 1;
  }

  return (pairs);
}

proc searchIndex(poly f, ideal G) {
  int idx = -1;
  if (size(G) == 0) {
    return (idx);
  }
  int i;
  for (i = 1; i <= size(G); i++) {
    if (f == G[i]) {
      idx = i;
      break;
    }
  }

  return (idx);
}

proc showPairs(list pairs, ideal G) {
  string res;
  if (size(pairs) == 0) {
    return (res);
  }

  int i;
  res = res + "Pairs = [" + newline;
  for (i = 1; i <= size(pairs); i++) {
    res = res + "    (G[" + string(searchIndex(pairs[i][1], G)) + "], G[" + string(searchIndex(pairs[i][2], G)) + "])," + newline;
  }
  res = res + "]." + newline;

  return (res);
  
}

proc randomizeSet(L) {
  if (typeof(L) != "ideal" && typeof(L) != "list") {
    ERROR("randomizeSet: L must be either an ideal or a list!");
  }

  if (size(L) <= 1) {
    return (L);
  }

  list used_indices;
  int size_used = 0;
  int size_L = size(L);
  int idx;

  list L_new;
  
  while (size_used < size_L) {
    idx = random(1, size_L);
    if (!listContains(used_indices, idx)) {
      L_new = insert(L_new, L[idx], size(L_new));
      used_indices = insert(used_indices, idx, size(used_indices));
      size_used = size_used + 1;
    }
  }

  if (typeof(L) == "ideal") {
    return (listToIdeal(L_new));
  } else {
    return (L_new);
  }
}

proc generalSimplifyBasisRaw(ideal G, ideal E, list N, int random_flag) {
  if (size(G) <= 1) {
    return (G);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def G = imap(BR, G);
    def E = imap(BR, E);
    if (!defined(N)) {
      def N = imap(BR, N);
    }
    ring_flag = 1;
  }

  if (random_flag) {
    ideal G_old = randomizeSet(G);
  } else {
    ideal G_old = sortSetDesc(G);
  }
  ideal I;
  int i;
  for (i = 1; i <= size(G_old); i++) {
    printf("Now consider %s:", G_old[i]);
    I = deletePolyFromIdeal(G, G_old[i]);
    if (generalSimplifyRaw(G_old[i], I, E, N) == 0) {
      G = I;
    }
  }
  ideal G_simpl = sortSetDesc(G);
  if (ring_flag) {
    if (size(G_simpl) == 0) {
      setring BR;
      return (ideal());
    } else {
      setring BR;
      def G_simpl = imap(@RP, G_simpl);
    }
  }

  return (G_simpl);
}

proc generalSimplifyBasis(ideal G, ideal E, list N) {
  if (size(G) <= 1){
    return (G);
  }

  int ring_flag = 0;
  if (nameof(basering) != "@RP") {
    def BR = basering;
    setring @RP;
    def G = imap(BR, G);
    def E = imap(BR, E);
    if (!defined(N)) {
      def N = imap(BR, N);
    }
    ring_flag = 1;
  }

  ideal G_old = sortSetDesc(G);
  ideal I;
  int i;
  for (i = 1; i <= size(G_old); i++) {
    I = deletePolyFromIdeal(G, G_old[i]);
    G = insertPolyWithGenSimpl(I, G_old[i], E, N);
  }

  ideal G_simpl = G;

  if (ring_flag) {
    if (size(G_simpl) > 0) {
      setring BR;
      def G_simpl = imap(@RP, G_simpl);
    } else {
      setring BR;
      return (ideal());
    }
  }

  return (G_simpl);
}

proc mcgbGenerate(ideal E, list N, ideal F, int random_flag) {
  // basering is @R.
  set_global_rings();
  set_global_rings_mcgb();
  set_global_objects();

  fprintf(special_out, "----------------NEW-----------------");
  
  if (size(F) <= 1) {
    return (F);
  }

  if (size(N) == 0){
    N = 1;
  }

  if (random_flag) {
    F = randomizeSet(F);
  } else {
    F = sortSetDesc(F);
  }

  ideal G = F;
  
  // Build the list of tuples of G.
  int i, j;
  list pairs;
  for (i = 1; i < size(G); i++) {
    for (j = i+1; j <= size(G); j++) {
      ideal tuple;
      if (lesspoly(G[i], G[j])) {
	tuple = G[i], G[j];
      } else {
	tuple = G[j], G[i];
      }
      pairs = insert(pairs, tuple, size(pairs));
    }
  }
  pairs = sortPairs(pairs);

  def BR = basering;
  setring @RP;
  def G = imap(BR, G);
  def pairs = imap(BR, pairs);
  def E = imap(BR, E);
  if (!defined(N)) {
    def N = imap(BR, N);
  }

  ideal cur_pair;
  int global_simpl_flag = 1;
  while (size(pairs) > 0) {
    int simpl_flag = 1;
    if (random_flag) {
      G = randomizeSet(G);
    } else {
      G = sortSetAsce(G);
    }
    cur_pair = pairs[random(1, size(pairs))];
    fprintf(special_out, "=====================");
    fprintf(special_out, "G = [");
    for (i = 1; i <= size(G); i++) {
      fprintf(special_out, "  G[%s] = %s,", string(i), showParamPoly(G[i]));
    }
    fprintf(special_out, "].");
    fprintf(special_out, "Now consider:");
    fprintf(special_out, "G[%s] = %s", string(searchIndex(cur_pair[1], G)), showParamPoly(cur_pair[1]));
    fprintf(special_out, "G[%s] = %s", string(searchIndex(cur_pair[2], G)), showParamPoly(cur_pair[2]));
    /*printf("========================");
    printf("Now consider:");
    printf("G[%s] = %s", string(searchIndex(cur_pair[1], G)), showParamPoly(cur_pair[1]));
    printf("G[%s] = %s", string(searchIndex(cur_pair[2], G)), showParamPoly(cur_pair[2]));*/
    (G, pairs, simpl_flag) = mcgbGenRec(G, pairs, cur_pair, E, N, E, N, simpl_flag);
    if (simpl_flag == 0) {
      global_simpl_flag = 0;
    }
    pairs = deletePair(pairs, cur_pair);
    fprintf(special_out, "|G| = %s.", string(size(G)));
    fprintf(special_out, "%s", showPairs(pairs, G));
    printf("|G| = %s.", string(size(G)));
    printf("|Pairs| = %s.", string(size(pairs)));
  }

  if (global_simpl_flag && size(G) > 1) {
    G = generalSimplifyBasisRaw(G, E, N, random_flag);
  }
  
  G = makeSetParamMonic(G);

  setring BR;
  def G_res = imap(@RP, G);

  return (G_res);
  
}
