LIB "mcgb.lib";
LIB "mcgbcheck.lib";
LIB "completion.lib";
LIB "buchtrace.lib";

proc sucheBeispiel(ideal G, list Modcgs, ideal M1, list cgs_m1, ideal M_simpl, list cgs_simpl, ideal M_step) {
  // Without updating CGS, result is not CGB.
  printf("Without updating CGS:");
  ideal M_falsche = mcgbMainFalscher(G, Modcgs);
  int valid_flag = check_validity(idealToList(M_falsche), Modcgs);
  if (valid_flag == 1) {
    printf("Result is still MCGB.");
  } else {
    if (valid_flag == -1) {
      printf("Result is a CGB, not minimal!");
    } else {
      printf("RESULT IS NOT EVEN A CGB!");
    }
  }


  // Branch split on CGS.
  if (size(cgs_m1) > size(Modcgs)) {
    printf("CGS of M has branch split!");
  } else {
    printf("CGS of M has NO branch split!");
  }

  // M_simpl < M1.
  int cmp_flag = lessSet(idealToList(M_simpl), idealToList(M1));
  if (cmp_flag == 1) {
    printf("M_simpl is better than M!");
  } else {
    if (cmp_flag == 2) {
      printf("M_simpl is the same as M!");
    } else {
      printf("M_simpl is worse than M!");
    }
  }

  // M_step < M_simpl.
  cmp_flag = lessSet(idealToList(M_step), idealToList(M_simpl));
  if (cmp_flag == 1) {
    printf("M_step is better than M_simpl!");
  } else {
    if (cmp_flag == 2) {
      printf("M_step is the same as M_simpl!");
    } else {
      printf("M_step is worse than M_simpl!");
    }
  }

}

proc simulate2(ideal E, list N, ideal F, int sim_times, link out, int debug_mode, intvec sim_option) {
  def BR = basering;
  system("--no-warn", 1);
  system("--ticks-per-sec", 1000);

  exportto(Top, out);
  exportto(Top, debug_mode);
  link special_out = "debug_info.mp";
  link time_res = "time_info.mp";
  exportto(Top, special_out);
  open(out);
  open(special_out);
  open(time_res);


  int gen_simpl_flag = 1;
  
  int i, j;

  // Print the ring configuration.
  fprintf(out, "The given ring is:");
  fprintf(out, "%s" + newline, BR);

  fprintf(time_res, newline + "+++++++++++++++++++++");
  fprintf(time_res, "The given ring is:");
  fprintf(time_res, "%s"+newline, BR);

  // Print the given parametric ideal.
  fprintf(out, "F = {");
  if (size(F) > 0) {
    for (i = 1; i < size(F); i++) {
      fprintf(out, "%s, ", F[i]);
    }
    fprintf(out, "%s" + newline + "}." + newline, F[size(F)]);
  } else {
    fprintf(out, newline + "}." + newline);
  }

  // Print the given parameter space.
  fprintf(out, "E = {%s}." + newline, E);
  fprintf(out, "N = {%s}." + newline, string(N));

  // KSWCGB and KSWCGS.

  set_global_rings_mcgb();
  

  
  set_global_rings();
  
  
  ideal G_origin;
  list Modcgs;
  timer = 0;
  int cnt_Time = timer;
  (G_origin, Modcgs) = cgb_mod(F, E, N, 1, out);
  int time_cnt_KSW = timer - cnt_Time;
  fprintf(time_res, "|CGS| = %s.", string(size(Modcgs)));
  fprintf(time_res, "|G| = %s.", string(size(G_origin)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_KSW));

  
  G_origin = sortSetAsce(G_origin);
  printf("Step 0 is finished!");
  list all_polys = idealToList(G_origin);
  
  set_global_rings_mcgb();
  ideal G_init = purifyCGB(G_origin);
  G_init = sortSetAsce(G_init);
  all_polys = mergeList(all_polys, idealToList(G_init));
  exportto(Top, G_init);
  exportto(Top, Modcgs);

  ideal G_comp = mcgbGenerateComp(E, N, F, 0);
  G_comp = sortSetAsce(G_comp);
  all_polys = mergeList(all_polys, idealToList(G_comp));
  
  ideal RGB = getRGB(F);
  all_polys = mergeList(all_polys, idealToList(RGB));
  
  ideal M1;
  list cgs_m1;
  timer = 0;
  cnt_Time = timer;
  (M1, cgs_m1) = mcgbMainComp(G_init, Modcgs);
  int time_cnt_MCGB = timer - cnt_Time;
  fprintf(time_res, "|CGS_M| = %s.", string(size(cgs_m1)));
  fprintf(time_res, "|M|: %s", string(size(M1)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_MCGB));
  all_polys = mergeList(all_polys, idealToList(M1));
  
  ideal M2;
  list cgs_m2;
  timer = 0;
  cnt_Time = timer;
  (M2, cgs_m2) = getMCGBComp(E, listToIdeal(N), G_init, Modcgs);
  int time_cnt_MSIMPL = timer - cnt_Time;
  fprintf(time_res, "|CGS_M_SIMPL| = %s.", string(size(cgs_m2)));
  fprintf(time_res, "|M_simpl| = %s.", string(size(M2)));
  fprintf(time_res, "Time Used: %s ms." + newline, string(time_cnt_MSIMPL));
  all_polys = mergeList(all_polys, idealToList(M2));

  fprintf(time_res, "Total time of MCGB: %s ms;", string(time_cnt_MCGB+time_cnt_KSW));
  fprintf(time_res, "Percentage of MCGB: %s / %s.", string(time_cnt_MCGB), string(time_cnt_MCGB + time_cnt_KSW));
  fprintf(time_res, "Total time of M_simpl: %s ms;", string(time_cnt_MSIMPL + time_cnt_KSW));
  fprintf(time_res, "Percentage of M_simpl: %s / %s.", string(time_cnt_MSIMPL), string(time_cnt_MSIMPL + time_cnt_KSW));
 
  ideal MCGB_step;
  list cgs_step;
  (MCGB_step, cgs_step) = getMCGBNew1(E, listToIdeal(N), F, 1);
  all_polys = mergeList(all_polys, idealToList(MCGB_step));
  
  
  all_polys = sortSetAsce(all_polys);
  exportto(Top, all_polys);

  fprintf(out, "------------------------" + newline);
  fprintf(out, "RGB" + newline);
  showRGB(RGB, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(RGB)));
  check_validity(idealToList(RGB), Modcgs);

  fprintf(out, "---------------------------" + newline);
  fprintf(out, "M1" + newline);
  showCCGB(M1, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(M1)));
  check_validity(idealToList(M1), Modcgs);

  fprintf(out, "---------------------------" + newline);
  fprintf(out, "M2" + newline);
  showCCGB(M2, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(M2)));
  check_validity(idealToList(M2), Modcgs);

  
  fprintf(out, "---------------------------" + newline);
  fprintf(out, "MCGB_step" + newline);
  showCCGB(MCGB_step, all_polys, out);
  fprintf(out, "Size is: %s." + newline, string(size(MCGB_step)));
  check_validity(idealToList(MCGB_step), Modcgs);

  fprintf(out, "=============Faith=================" + newline);
  fprintf(out, "Before preprocess:");
  fprintf(out, "%s" + newline, StringCGB(G_origin, all_polys));
  fprintf(out, newline + "Size is: %s." + newline, string(size(G_origin)));

  fprintf(out, "After preprocess:");
  fprintf(out, "%s" + newline, StringCGB(G_init, all_polys));
  fprintf(out, newline + "Size is: %s." + newline, string(size(G_init)));
  check_validity(idealToList(G_init), Modcgs);
  
  fprintf(out, "--------------------------------------" + newline);
  fprintf(out, "%s" + newline, StringModCGS_mod(F, Modcgs, 1));


  sucheBeispiel(G_init, Modcgs, M1, cgs_m1, M2, cgs_m2, MCGB_step);
  
  
  
  fprintf(out, "-----------Completion----------" + newline);
  fprintf(out, "Starting from RGB, G_comp = ");
  showCCGB(G_comp, all_polys, out);
  check_validity(idealToList(G_comp), Modcgs);
  
  
  
  
  
  close(out);
  close(special_out);
  close(time_res);
}

proc simulate3(ideal E, list N, ideal F, int sim_times, link out, int debug_mode, intvec sim_option) {
  def BR = basering;
  system("--no-warn", 1);
  system("--ticks-per-sec", 1000);

  exportto(Top, out);
  exportto(Top, debug_mode);
  link special_out = "debug_info.mp";
  link time_res = "time_info.mp";
  exportto(Top, special_out);
  open(out);
  open(special_out);
  open(time_res);


  int gen_simpl_flag = 1;
  
  int i, j;

  // Print the ring configuration.
  fprintf(out, "The given ring is:");
  fprintf(out, "%s" + newline, BR);

  fprintf(time_res, newline + "+++++++++++++++++++++");
  fprintf(time_res, "The given ring is:");
  fprintf(time_res, "%s"+newline, BR);

  // Print the given parametric ideal.
  fprintf(out, "F = {");
  if (size(F) > 0) {
    for (i = 1; i < size(F); i++) {
      fprintf(out, "%s, ", F[i]);
    }
    fprintf(out, "%s" + newline + "}." + newline, F[size(F)]);
  } else {
    fprintf(out, newline + "}." + newline);
  }

  // Print the given parameter space.
  fprintf(out, "E = {%s}." + newline, E);
  fprintf(out, "N = {%s}." + newline, string(N));

  // KSWCGB and KSWCGS.

  set_global_rings_mcgb();
  

  
  set_global_rings();



  ideal G_origin;
  list Modcgs;
  (G_origin, Modcgs) = cgb_mod(F, E, N, 1, out);
  /* 
  printf("Start computing G_cgb");
  ideal G_cgb = cgbGenerate(E, N, F, 0);
  list all_polys = idealToList(G_cgb);

 
  printf("Start computing G_comp");

  */

  ideal G_comp = mcgbGenerateComp(E, N, F, 0);
  list all_polys = idealToList(G_comp);
  /*
  printf("Start computing G_RGB");
  
  ideal G_RGB = mcgbGenerate(E, N, F, 0);
  all_polys = mergeList(all_polys, idealToList(G_RGB));
  
  
  fprintf(out, "CGB computed from F:");
  showCCGB(G_cgb, all_polys, out);
  check_validity(idealToList(G_cgb), Modcgs);
  */
  all_polys = sortSetAsce(all_polys);
  
  fprintf(out, "Starting from F, G_comp = ");
  showCCGB(G_comp, all_polys, out);
  check_validity(idealToList(G_comp), Modcgs);
  /*
  fprintf(out, "Starting from RGB, G_comp = ");
  showCCGB(G_RGB, all_polys, out);
  check_validity(idealToList(G_RGB), Modcgs);
  

  ideal RGB = getRGB(F);
  check_validity(idealToList(RGB), Modcgs);
  */
  close(out);
  close(special_out);
  close(time_res);
}

proc simulate(ideal E, list N, ideal F, int sim_times, link out, int debug_mode, intvec sim_option) {
  def BR = basering;
  system("--no-warn", 1);

  exportto(Top, out);
  exportto(Top, debug_mode);
  //open(out);


  int gen_simpl_flag = 1;
  
  int i, j;

  // Print the ring configuration.
  fprintf(out, "The given ring is:");
  fprintf(out, "%s" + newline, BR);


  // Print the given parametric ideal.
  fprintf(out, "F = {");
  if (size(F) > 0) {
    for (i = 1; i < size(F); i++) {
      fprintf(out, "%s, ", F[i]);
    }
    fprintf(out, "%s" + newline + "}." + newline, F[size(F)]);
  } else {
    fprintf(out, newline + "}." + newline);
  }

  // Print the given parameter space.
  fprintf(out, "E = {%s}." + newline, E);
  fprintf(out, "N = {%s}." + newline, string(N));

  // KSWCGB and KSWCGS.

  set_global_rings_mcgb();
  

  
  set_global_rings();



  ideal G_origin;
  list Modcgs;
  (G_origin, Modcgs) = cgb_mod(F, E, N, 1, out);

  ideal M;
  list cgs_m;
  (M, cgs_m) = mcgbMainComp(G_origin, Modcgs);

  list cgs_recover = buildCGS(M);

  if (size(cgs_recover) < size(Modcgs)) {
    printf("CGS recovered is BETTER than original CGS!");
  } else {
    if (size(cgs_recover) == size(Modcgs)) {
      printf("CGS recovered is SAME as original CGS!");
    } else {
      printf("CGS is WORSE than original CGS!");
    }
  }


  //  close(out);
}
