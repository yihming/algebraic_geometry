LIB "poly.lib";
LIB "primdec.lib";
LIB "qhmoduli.lib";
LIB "teachstd.lib";

LIB "../CGB/cgb_mod.lib";
proc set_global_rings_mcgb() {
  // Basering is K[U][X].
  def BR = basering;
  def @R = basering;

  def Rx = ringlist(BR);
  def @P = ring(Rx[1]);
  
  Rx[1] = 0;
  def D = ring(Rx);
  def @RP = D + @P;
  
  exportto(Top, @R);
  exportto(Top, @P);
  exportto(Top, @RP);

  setring(BR);
}

proc ideal_exclude(ideal I, ideal J) {
  // Basering is @RP.
  if (size(I) == 0) {
    return (ideal());
  }


  if (size(J) == 0) {
    return (I);
  }

  poly prod_J = 1;
  int i, j;
  for (i = 1; i <= size(J); i++) {
    prod_J = prod_J * J[i];
  }
  ideal FL_J = factorize(prod_J, 1);

  for (i = 1; i <= size(I); i++) {
    for (j = 1; j <= size(FL_J); j++) {
      if (reduce(I[i], groebner(ideal(FL_J[j]))) == 0) {
	I[i] = I[i] / FL_J[j];
      }
    }
  }

  return (radical(I));
}

proc getNSquareFreeFromProd(poly h) {
  // Basering is @RP.
  ideal FL = factorize(h, 1);
  if (size(FL) == 0) {
    return (list(0));
  }

  int i;
  list res_list;
  for (i = 1; i <= size(FL); i++) {
    res_list = insert(res_list, FL[i], size(res_list));
  }

  return (res_list);
}

proc idealUnion(ideal I, ideal J) {
  // Basering is @RP.
  int i;
  int n = size(I);

  for (i = 1; i <= size(J); i++) {
    I[n + i] = J[i];
  }

  return (I);
}


proc redRepN(ideal E, list N, poly c) {
  // Basering is @RP.
  // reduce c by radical(E).
  poly c_red = reduce(c, groebner(radical(E)));

  ideal E1 = radical(idealUnion(E, ideal(c_red)));
 
  poly h = 1;
  if (size(N) > 0) {
    int i;
    for (i = 1; i <= size(N); i++) {
      h = h * N[i];
    }
  }

  ideal res_E = ideal_exclude(E1, ideal(h));
  
  return (res_E, N);
}

proc redRepNN(ideal E, list N, poly c) {
  // Basering is @RP.
  // E is radical.
  poly c_red = reduce(c, groebner(E));

  int i;
  poly N_prod = 1;

  if (size(N) > 0) {
    for (i = 1; i <= size(N); i++) {
      N_prod = N_prod * N[i];
    }
  }

  poly h1 = N_prod * c_red;
  ideal newE = ideal_exclude(E, groebner(ideal(h1)));
  list newN = getNSquareFreeFromProd(h1);

  return (newE, newN);
}

proc splitBranch(ideal E, list N, poly c) {
  // Basering is @RP.
  list res_list;
  ideal E0;
  list N0;
  (E0, N0) = redRepN(E, N, c);
  list sub1 = E0, N0;
  res_list = insert(res_list, sub1, size(res_list));
  list sub2;
  if (groebner(E0)[1] == 1) {
    // (E0, N0) is inconsistent.
    sub2 = E, N;
  } else {
    ideal E1;
    list N1;
    (E1, N1) = redRepNN(E, N, c);
    sub2 = E1, N1;
  }
  res_list = insert(res_list, sub2, size(res_list));
  return (res_list);
}

proc checkNull(poly c, ideal E, list N) {
  // Basering is @RP.
  // (E, N) in R-representation.
  poly Nprod = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    Nprod = Nprod * N[i];
  }

  ideal Ered = radical(ideal_exclude(E, ideal(Nprod)));

  if (reduce(c, groebner(Ered)) == 0) {
    return (1);
  } else {
    return (0);
  }
}
/*
proc checkNullRRep(poly c, ideal E, list N) {
  // Basering is @RP.

  if (reduce(c, groebner(E)) == 0) {
    return (1);
  } 

  return (0);
}
*/

proc checkNonNull(poly c, ideal E, list N) {
  // Basering is @RP.
  list sub_branches = splitBranch(E, N, c);
  if (sub_branches[1][1] == 1) {
    return (1);
  } else { 
    return (0); 
  }
}

proc makeRRepInBranch(ideal E, list N) {
  // Basering is @RP.
  if (size(E) == 0 && size(N) == 0) {
    return (ideal(), list(1));
  }

  ideal newE = radical(E);
  
  poly prod_N = 1;
  int i;
  for (i = 1; i <= size(N); i++) {
    prod_N = prod_N * N[i];
  }
  poly prod_N_rem = reduce(prod_N, newE);
  ideal FL_N = factorize(prod_N_rem, 1);

  list newN;
  if (size(FL_N) == 0) {
    newN = 0;
  } else {
    for (i = 1; i <= size(FL_N); i++) {
      newN = insert(newN, FL_N[i], size(newN));
    }
  }

  return (newE, newN);
}

proc makeRRep(list modcgs) {
  // Basering is @RP.
  list modcgsRed;
  int i;
  for (i = 1; i <= size(modcgs); i++) {
    ideal E;
    list N;
    (E, N) = makeRRepInBranch(modcgs[i][1], modcgs[i][2]);
    list branch = E, N, modcgs[i][3];
    modcgsRed = insert(modcgsRed, branch, size(modcgsRed));
  }

  return (modcgsRed);
}

proc appearsInBranch(poly f, list branch) {
  // Basering is @RP.
  f = f / leadcoef(f);
  if (size(branch[3]) == 0) {
    return (0);
  } 

  ideal E = branch[1];
  list N = branch[2];

  int i;
  for (i = 1; i <= size(branch[3]); i++) {
    poly g = branch[3][i][1] + branch[3][i][2];
    g = g / leadcoef(g);
    if (g == f) {
      return (1);
    } 
  }

  return (0);
}

proc lppX(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def m = leadmonom(P);
  if (flag) {
    setring(BR);
    def m = imap(@R, m);
  }

  return (m);
}

proc leadcoef_U(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }
  poly C = leadcoef(P);
  
  if (flag) {
    setring(BR);
    def C = imap(@R, C);
  }

  return (C);
}

proc lm_X(poly P) {
  int flag = 0;
  if (nameof(basering) != "@R") {
    def BR = basering;
    setring(@R);
    flag = 1;
    def P = imap(BR, P);
  }

  def T = lead(P);
  if (flag) {
    setring(BR);
    def T = imap(@R, T);
  }

  return (T);
}

proc deletePolyFromList(list L, poly f) {
  // Basering is @RP.
  if (size(L) == 0) {
    return (list());
  }

  int i;
  for (i = 1; i <= size(L); i++) {
    if (f == L[i]) {
      L = delete(L, i);
      break;
    }
  }

  return (L);
}

proc getCandidatePolys(poly pp, list M, ideal E) {
  if (size(M) == 0) {
    return (list());
  }

  int i;
  list G_can;
  for (i = 1; i <= size(M); i++) {
    poly cur_g = M[i];
    while (cur_g != 0) {
      if (lppX(cur_g) == pp) {
	if (reduce(leadcoef_U(cur_g), E) != 0) {
	  G_can = insert(G_can, M[i], size(G_can));
	}
	break;
      }
      cur_g = cur_g - lm_X(cur_g);
    }
  }

  return (G_can);
}

proc deletePolyFromG(list G, poly f) {
  // Basering is @RP.
  if (size(G) == 0) {
    return (list());
  }

  int i;
  for (i = 1; i <= size(G); i++) {
    if (G[i][1] + G[i][2] == f) {
      G = delete(G, i);
      break;
    }
  }

  return (G);
}

proc insertPolyIntoG(list G, poly f, ideal E, list N) {
  // Basering is @RP.
  poly f_null;
  poly f_nonnull;
  
  while (f > 0) {
    poly cur_coef = leadcoef_U(f);
    if (checkNull(cur_coef, E, N)) {
      f_null = f_null + lm_X(f);
    } else {
      f_nonnull = f_nonnull + lm_X(f);
    }
    f = f - lm_X(f);
  }

  list l = f_nonnull, f_null;
  G = insert(G, l, size(G));
  return (G);
}

proc lookUpIndex(poly f) {
  // Basering is @RP.
  if (size(CGB) == 0) {
    return (0);
  } else {
    int i;
    for (i = 1; i <= size(CGB); i++) {
      if (CGB[i] == f) {
	return (i);
      }
    }
    return (0);
  }
}

proc checkEssentialByHC(poly f, poly pf, list higher_coefs, poly g, list G_can, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  if (size(higher_coefs) == 0) {
    // {g} covers f in (E, N).
    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));

    int idx_g = lookUpIndex(g);
    int idx_f = lookUpIndex(f);

    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  } else {
    int i;
    for (i = 1; i <= size(higher_coefs); i++) {
      poly cur_c = higher_coefs[i];
      
      if (checkNull(cur_c, E, N)) {
	// sigma(cur_c) is always 0.
	i++; // In SINGULAR, we need this statement before continue.
	continue;
      } else {
	if (checkNonNull(cur_c, E, N)) {
	  // sigma(cur_c) is never 0.
	  G_can = deletePolyFromList(G_can, g);
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "There is some non-null higher coef %s. So %s cannot cover %s in (<%s>, {%s})", cur_c, g, f, E, N);
	  }
	  return (checkEssentialInBranch(f, pf, G_can, E, N, G_branch, BL));
	} else {
	  // sigma(cur_c) is not determined.
	  if (defined(debug_mode) && debug_mode >= 1) {
	    fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cur_c);
	  }
	  list branches = splitBranch(E, N, cur_c);
	  int is_essential;
	  if (defined(debug_mode) && debug_mode == 1) {
	    fprintf(out, "Come to sub-branch (<%s> {%s}):", branches[1][1], branches[1][2]);
	  }
	  (is_essential, BL) = checkEssentialInBranch(f, pf, G_can, branches[1][1], branches[1][2], G_branch, BL);
	  if (is_essential) {
	    return (1, BL);
	  } else {
	    G_can = deletePolyFromList(G_can, g);
	    if (defined(debug_mode) && debug_mode == 1) {
	      fprintf(out, "%s is covered in the first sub-branch (<%s>, {%s}).", f, branches[1][1], branches[1][2]);
	      fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
	    }
	    return (checkEssentialInBranch(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
	  }
	}
      }

    }

    G_branch = deletePolyFromG(G_branch, f);
    G_branch = insertPolyIntoG(G_branch, g, E, N);
    BL = insert(BL, list(E, N, G_branch), size(BL));

    int idx_g = lookUpIndex(g);
    int idx_f = lookUpIndex(f);

    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "{f_%s = %s} covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_g), string(g), string(idx_f), string(f), string(E), string(N));
    }
    return (0, BL);
  }
}

proc getHigherCoefs(poly f, poly pp) {
  // Basering is @RP.
  list higher_coefs;
  while (lppX(f) > pp) {
    higher_coefs = insert(higher_coefs, leadcoef_U(f), size(higher_coefs));
    f = f - lm_X(f);
  }

  return (higher_coefs);
}

proc getCoefOfPP(poly f, poly pp) {
  // Basering is @RP.
  while (lppX(f) >= pp) {
    if (lppX(f) == pp) {
      return (leadcoef_U(f));
    }
    f = f - lm_X(f);
  }

  return (0);
}

proc checkEssentialInBranch(poly f, poly pf, list M, ideal E, list N, list G_branch, list BL) {
  // Basering is @RP.
  list G_can = getCandidatePolys(pf, M, E);

  if (size(G_can) == 0) {
    list branch = E, N, list(0);
    BL = insert(BL, branch, size(BL));

    int idx_f = lookUpIndex(f);

    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "No subsets of M covers f_%s = %s in (<%s>, {%s})" + newline, string(idx_f), string(f), string(E), string(N));
      fprintf(out, "%s is essential due to (<%s>, {%s}).", f, E, N);
    }
    return (1, BL);
  }

  int idx = random(1, size(G_can));
  poly g = G_can[idx];
  list higher_coefs = getHigherCoefs(g, pf);
  poly cp = getCoefOfPP(g, pf);
  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "Coef(%s, %s) = %s", g, pf, cp);
  }
  if (checkNonNull(cp, E, N)) {
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Coef(g, pf) is non-null. Now check higher coefs:");
    }
    return (checkEssentialByHC(f, pf, higher_coefs, g, G_can, E, N, G_branch, BL));
  } else {
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Split branch (<%s>, {%s}) w.r.t. %s:", E, N, cp);
    }
    list branches = splitBranch(E, N, cp);
    int is_essential;
    list G_can_rem = deletePolyFromList(G_can, g);
    if (defined(debug_mode) && debug_mode >= 1) {
      fprintf(out, "Come to sub-branch (<%s>, {%s}):", branches[1][1], branches[1][2]);
    }
    (is_essential, BL) = checkEssentialInBranch(f, pf, G_can_rem, branches[1][1], branches[1][2], G_branch, BL);
    if (is_essential) {
      return (1, BL);
    } else {
      int idx_f = lookUpIndex(f);
      if (defined(debug_mode) && debug_mode >= 1) {
	fprintf(out, "f_%s = %s is covered in the first sub-branch (<%s>, {%s}).", string(idx_f), f, branches[1][1], branches[1][2]);
	fprintf(out, "Continue with the other sub-branch (<%s>, {%s}):", branches[2][1], branches[2][2]);
      }
      return (checkEssentialInBranch(f, pf, G_can, branches[2][1], branches[2][2], G_branch, BL));
    }
  }
}

proc checkEssential(poly f, list M, list modcgs) {
  // Basering is @RP.
  list BL;
  int i, j;
  
  for (i = 1; i <= size(modcgs); i++) {
    if (appearsInBranch(f, modcgs[i])) {
      // f appears in this branch.
      poly pf;
      for (j = 1; j <= size(modcgs[i][3]); j++) {
	if (f == modcgs[i][3][j][1] + modcgs[i][3][j][2]) {
	  pf = lppX(modcgs[i][3][j][1]);
	}
      }
      int is_essential;
      list MRem = deletePolyFromList(M, f);
      ideal E_cur = modcgs[i][1];
      list N_cur = modcgs[i][2];
      list G_cur = modcgs[i][3];
      if (defined(debug_mode) && debug_mode == 1) {
	fprintf(out, "Now come to Branch %s: (<%s>, {%s}):", string(i), E_cur, N_cur);
      }
      (is_essential, BL) = checkEssentialInBranch(f, pf, MRem, E_cur, N_cur, G_cur, BL);
      if (is_essential) {
	if (defined(debug_mode) && debug_mode == 1) {
	  fprintf(out, "%s is essential" + newline + "=================", string(f));
	}
	return (1, list());
      } 
    }
  }

  if (defined(debug_mode) && debug_mode == 1) {
    fprintf(out, "%s is non-essential" + newline + "=====================", string(f));
  }
  return (0, BL);
}

proc listContains(list l, poly f) {
  if (size(l) == 0) {
    return (0);
  } 

  int i;
  for (i = 1; i <= size(l); i++) {
    if (l[i] == f) {
      return (1);
    }
  }

  return (0);
}

proc listContainsList(list m_l, list m) {
  if (size(m_l) == 0) {
    return (0);
  }

  int i;
  for (i = 1; i <= size(m_l); i++) {
    if (listEquals(m_l[i], m)) {
      return (1);
    }
  }

  return (0);
}

proc listEquals(list l1, list l2) {
  if (size(l1) != size(l2)) {
    return (0);
  }

  if (size(l1) == 0) {
    if (size(l2) == 0) {
      return (1);
    } else {return (0);}
  }

  if (size(l2) == 0) {
    return (0);
  }

  // General Case.
  int i;
  for (i = 1; i <= size(l1); i++) {
    if (!listContains(l2, l1[i])) {
      return (0);
    }
  }

  for (i = 1; i <= size(l2); i++) {
    if (!listContains(l1, l2[i])) {
      return (0);
    }
  }

  return (1);
}

proc sortCGB(ideal G) {
  // Basering is @RP.
  
  list sort_res;
  sort_res = sort(G, size(G)..1);
  
  ideal G_sorted = sort_res[1];
  
  setring @R;
  def G_forprint = imap(@RP, G_sorted);
  fprintf(out, "Sorted CGB is: %s", G_forprint);
  setring @RP;

  return (G_sorted);
}

proc mcgbMain(ideal E, list N, ideal F) {
  // basering is @R.
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();

  // Switch to @RP.
  setring(@RP);
  //def G_origin = imap(@R, G);
  
  //def G = sortCGB(G_origin);
  def G = imap(@R, G);

  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;
  for (i = 1; i <= size(G); i++) {
    M[i] = G[i];
  }

  int size_cgb = size(G);
  list checked_indices;

  while (size(checked_indices) < size_cgb) {
    int cur_idx = random(1, size_cgb);
    while (listContains(checked_indices, cur_idx)) {
      cur_idx = random(1, size_cgb);
    }
    poly cur_f = G[cur_idx];
    //poly cur_f = G[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check f_%s = %s:", string(cur_idx), cur_f);
    }
    int is_essential;
    list BL;
    (is_essential, BL) = checkEssential(cur_f, M, modcgsRed);
    if (is_essential == 0) {
      
      list modcgs1;
      for (j = 1; j <= size(modcgsRed); j++) {
	if (!appearsInBranch(cur_f, modcgsRed[j])) {
	  modcgs1 = insert(modcgs1, modcgsRed[j], size(modcgs1));
	}
      }
      for (j = 1; j <= size(BL); j++) {
	modcgs1 = insert(modcgs1, BL[j], size(modcgs1));
      }
      modcgsRed = modcgs1;
      M = deletePolyFromList(M, cur_f);
    } 
    checked_indices = insert(checked_indices, cur_idx, size(checked_indices));
  }
  

  // Switch back to @R.
  setring(@R);
  def M = imap(@RP, M);
  def modcgsRed = imap(@RP, modcgsRed);

  return (M, modcgsRed);
}

proc mcgbMainProvisional(ideal G, list modcgs) {
  // Basering is @R.

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();

    // Switch to @RP.
  setring(@RP);
  def G = imap(@R, G);

  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  list M;
  int i, j;
  for (i = 1; i <= size(G); i++) {
    M[i] = G[i];
  }

  int size_cgb = size(G);
  //list checked_indices;

  //  while (size(checked_indices) < size_cgb) {
  for (i = 1; i <= size_cgb; i++) {
    //int cur_idx = random(1, size_cgb);
    //while (listContains(checked_indices, cur_idx)) {
    //cur_idx = random(1, size_cgb);
    //}
    //poly cur_f = G[cur_idx];
    poly cur_f = G[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check f_%s = %s:", string(cur_idx), cur_f);
    }
    int is_essential;
    list BL;
    (is_essential, BL) = checkEssential(cur_f, M, modcgsRed);
    if (is_essential == 0) {
      
      list modcgs1;
      for (j = 1; j <= size(modcgsRed); j++) {
	if (!appearsInBranch(cur_f, modcgsRed[j])) {
	  modcgs1 = insert(modcgs1, modcgsRed[j], size(modcgs1));
	}
      }
      for (j = 1; j <= size(BL); j++) {
	modcgs1 = insert(modcgs1, BL[j], size(modcgs1));
      }
      modcgsRed = modcgs1;
      M = deletePolyFromList(M, cur_f);
    } 
    //checked_indices = insert(checked_indices, cur_idx, size(checked_indices));
  }
  

  // Switch back to @R.
  setring(@R);
  def M = imap(@RP, M);
  def modcgsRed = imap(@RP, modcgsRed);

  return (M, modcgsRed);
}

// For Canonical CGB.

proc monic(poly f) {
  // basering is @RP.
  if (f == 0) {
    return (f);
  } else {
    return (f / leadcoef(f));
  }
}

proc lesscoef(poly coef_f, coef_g) {
  if (coef_f == 0 && coef_g == 0) {
    return (2);
  }

  if (leadmonom(coef_f) < leadmonom(coef_g)) {
    return (1);
  } else {
    if (leadmonom(coef_f) > leadmonom(coef_g)) {
      return (0);
    } else {
      if (leadcoef(coef_f) == leadcoef(coef_g)) {
	return (lesscoef(coef_f - lead(coef_f), coef_g - lead(coef_g)));
      } else {
	return (leadcoef(coef_f) < leadcoef(coef_g));
      }
    }
  }
}

proc lesspoly(poly f, poly g) 
"
f, g are monic polynomials.
"
{
  // basering is @RP.
  if (f == 0 || g == 0) {
    return (2);
  }

  if (lppX(f) < lppX(g)) {
    return (1);
  } else {
    if (lppX(f) > lppX(g)) {
      return (0);
    } else {
      poly lc_f = leadcoef_U(f);
      poly lc_g = leadcoef_U(g);
      if (lc_f != lc_g) {
	return (lesscoef(lc_f, lc_g));
      } else {
	return (lesspoly(f - lm_X(f), g - lm_X(g)));
      }
    }
  }
}

proc sortPolyDesc(ideal I) {
  
}

proc idealExclude(ideal M, poly f) {

}

proc updateCGS(list CGS, poly f, list BL) {

}

proc deleteGeneratorFromIdeal(ideal M, poly f) {

}

proc trySubstitute(poly f, poly f_red, ideal M, list CGS) {

}

proc replaceGeneratorInIdeal(ideal M, poly f_old, poly f_new) {

}

proc ccgbMain(ideal E, list N, ideal F) {
  ideal G;
  list modcgs;

  (G, modcgs) = cgb_mod(F, E, N, out);

  if (size(G) == 0 || size(modcgs) == 0) {
    return (list());
  }

  set_global_rings_mcgb();

  // Switch to @RP.
  setring @RP;
  def G = imap(@R, G);
  G = sortPolyDesc(G);
  def CGB = G;
  exportto(Top, CGB);
  def modcgs = imap(@R, modcgs);

  list modcgsRed = makeRRep(modcgs);
  ideal M = G;
  int i, j;

  for (i = 1; i <= size(G); i++) {
    poly cur_g = G[i];
    if (defined(debug_mode) && debug_mode == 1) {
      fprintf(out, "Now check g_%s = %s:", string(i), cur_g);
    }
    int is_essential;
    list BL;
    poly g_red = reduce(cur_g, idealExclude(M, cur_g));
    if (g_red == 0 || g_red == cur_g) {
      // Notice: need to modify checkEssential with ideal M instead
      //   of list M.
      (is_essential, BL) = checkEssential(cur_g, M, modcgsRed);
      if (!is_essential) {
	modcgsRed = updateCGS(modcgsRed, cur_g, BL);
	M = deleteGeneratorFromIdeal(M, cur_g);
      }
    } else {
      int success; 
      (success, BL) = trySubstitute(cur_g, g_red, M, modcgsRed);
      if (success) {
	modcgsRed = updateCGS(modcgsRed, cur_g, BL);
	M = replaceGeneratorInIdeal(M, cur_g, g_red);
      }
    }
  } // End of for.

  // Switch back to @R.
  setring @R;
  def CCGB = imap(@RP, M);
  def CGSRed = imap(@RP, modcgsRed);
  
  return (CCGB, CGSRed);
}



proc showMCGB(list M, link out) {
    int i;

    fprintf(out, "M = [" + newline );
    if (size(M) == 0) {
        fprintf(out, newline);
    } else {
	for (i = 1; i < size(M); i++) {
	    fprintf(out, "%s,", M[i]);
	}
	fprintf(out, "%s." + newline, M[size(M)]);
    }
    fprintf(out, "].");
}
